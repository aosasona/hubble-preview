/*
 * This file was auto-generated by robin (https://github.com/aosasona/robin), do NOT edit it.
 **/

export type RequestOpts = {
  // The HTTP method to use for the request
  method: "GET" | "POST" | "PUT" | "DELETE" | "PATCH" | "OPTIONS" | "HEAD";

  // The headers to send with the request
  headers?: Record<string, string>;

  // The body of the request; this should be a JSON string
  body?: string;
}

export type HttpClientFn = (url: string, opts?: RequestOpts) => Promise<Response>;

export type ExtraFetchOpts = Exclude<RequestInit, "method" | "headers" | "body">;

export type ClientOpts = {
  // The full robin endpoint to connect to (e.g. http://localhost:8080/_robin)
  endpoint?: string;

  // Optional custom client function to use for making requests
  clientFn?: HttpClientFn;

  /**
   * Additional fetch options to pass to the underlying fetch API if the default client is being used (e.g. `mode`, `credentials`, etc.)
   * This will do nothing if a custom client function is provided, set the options there instead
   **/
  fetchOpts?: ExtraFetchOpts;
};

export type ProcedureType = "query" | "mutation";

export type Procedure = {
  payload: unknown;
  result: unknown;
};

export type ServerResponse<Result = unknown> = {
  ok: boolean;
  error?: unknown;
  data?: Result;
};

export type ProcedureSchema = Record<string, Procedure>;

export type ClientSchema = { queries: ProcedureSchema; mutations: ProcedureSchema };

export type SchemaBasedOnType<CSchema extends ClientSchema, Type extends ProcedureType> = CSchema[Type extends "query" ? "queries" : "mutations"];

export type PayloadOf<CSchema extends ClientSchema, PType extends ProcedureType, PName extends keyof SchemaBasedOnType<CSchema, PType>> = SchemaBasedOnType<
  CSchema,
  PType
>[PName]["payload"];

export type ResultOf<CSchema extends ClientSchema, PType extends ProcedureType, PName extends keyof SchemaBasedOnType<CSchema, PType>> = SchemaBasedOnType<
  CSchema,
  PType
>[PName]["result"];

export type ProcedureResult<CSchema extends ClientSchema, PType extends ProcedureType, PName extends keyof SchemaBasedOnType<CSchema, PType>> = ResultOf<CSchema, PType, PName>

export type RawCallOpts<CSchema extends ClientSchema, PType extends ProcedureType, PName extends keyof SchemaBasedOnType<CSchema, PType>> = {
  name: PName;
  payload: PayloadOf<CSchema, PType, PName>;
  extraHeaders?: Record<string, string>;
};

export type CallOpts<CSchema extends ClientSchema, PType extends ProcedureType, PName extends keyof SchemaBasedOnType<CSchema, PType>> = Omit<
  Omit<RawCallOpts<CSchema, "query", PName>, "name">,
  "payload"
>;

/** ================ GENERATED SCHEMA ================ **/
export type Schema = {
  queries: {
    "ping": {
      result: string;
      payload: void;
    };
    "mfa.load-session": {
      result: {
        session: {
          id: string;
          account_id: string;
          type: 'email' | 'totp';
          session_type: string;
          user_id: number;
          meta: { name?: string, email?: string };
          created_at: number;
          expires_at: number;
        };
        accounts: Array<{
          id: string;
          name: string | null;
          email: string | null;
          type: 'email' | 'totp';
          preferred: boolean;
        }>;
      };
      payload: string;
    };
    "me": {
      result: {
        user: {
          id: number;
          user_id: string;
          first_name: string;
          last_name: string;
          email: string;
          email_verified: boolean;
          username: string;
          avatar_id: string;
          created_at: number;
          last_updated_at: number;
        };
        workspaces: Array<{
          id: string;
          name: string;
          slug: string;
          owner_id: number;
          description: string;
          avatar_id: string;
          enable_public_indexing: boolean;
          invite_only: boolean;
          created_at: string;
          collections: Array<{
            id: string;
            name: string;
            slug: string;
            workspace_id: number;
            description: string;
            avatar_id: string;
            created_at: string;
            owner_id: number;
            members_count: number;
            entries_count: number;
          }>;
        }>;
      };
      payload: void;
    };
    "mfa.state": {
      result: {
        enabled: boolean;
        accounts: Array<{
          id: string;
          type: 'email' | 'totp';
          meta: { name: string; email: string } | { name: string };
          active: boolean;
          user_id: number;
          registered_at: string;
          last_used_at: string;
          preferred: boolean;
        }>;
        preferred_account_id: string;
      };
      payload: void;
    };
    "get-link-metadata": {
      result: {
        title: string;
        description: string;
        favicon: string;
        author: string;
        thumbnail: string;
        site_type: string;
        domain: string;
        link: string;
      };
      payload: string;
    };
    "entry.find": {
      result: {
        entry: {
          id: string;
          origin: string;
          name: string;
          content: string;
          text_content: string;
          version: number;
          type: 'link' | 'audio' | 'video' | 'image' | 'pdf' | 'interchange' | 'epub' | 'word_document' | 'presentation' | 'spreadsheet' | 'html' | 'markdown' | 'plain_text' | 'archive' | 'code' | 'comment' | 'other';
          parent_id: number;
          file_id?: string | null;
          filesize_bytes: number;
          status: 'queued' | 'processing' | 'completed' | 'failed' | 'canceled' | 'paused';
          queued_at: string;
          created_at: string;
          updated_at: string;
          archived_at: string;
          added_by: {
            first_name: string;
            last_name: string;
            username: string;
          };
          collection: {
            id: string;
            name: string;
            slug: string;
          };
          workspace: {
            id: string;
            name: string;
            slug: string;
          };
          metadata: import('./types').FileMetadata | import('./types').Metadata;
        };
      };
      payload: {
        entry_id: string;
        workspace_slug: string;
        collection_slug: string;
      };
    };
    "entry.search": {
      result: {
        results: {
          results: Array<{
            id: string;
            name: string;
            type: 'link' | 'audio' | 'video' | 'image' | 'pdf' | 'interchange' | 'epub' | 'word_document' | 'presentation' | 'spreadsheet' | 'html' | 'markdown' | 'plain_text' | 'archive' | 'code' | 'comment' | 'other';
            matches: Array<{
              id: number;
              index: number;
              text: string;
              rank: number;
              text_score: number;
              semantic_score: number;
              hybrid_score: number;
            }>;
            status: 'queued' | 'processing' | 'completed' | 'failed' | 'canceled' | 'paused';
            file_id?: string | null;
            filesize_bytes: number;
            relevance_percent: number;
            collection: {
              id: string;
              name: string;
              slug: string;
            };
            workspace: {
              id: string;
              name: string;
              slug: string;
            };
            created_at: string;
            updated_at: string;
            archived_at: string;
            metadata: import('./types').FileMetadata | import('./types').Metadata;
          }>;
          min_hybrid_score: number;
          max_hybrid_score: number;
        };
        query: string;
        time_taken_ms: number;
      };
      payload: {
        workspace_id?: string | null;
        workspace_slug?: string | null;
        query: string;
      };
    };
    "workspace.find": {
      result: {
        workspace: {
          id: string;
          name: string;
          slug: string;
          owner_id: number;
          description: string;
          avatar_id: string;
          enable_public_indexing: boolean;
          invite_only: boolean;
          created_at: string;
          collections: Array<{
            id: string;
            name: string;
            slug: string;
            workspace_id: number;
            description: string;
            avatar_id: string;
            created_at: string;
            owner_id: number;
            members_count: number;
            entries_count: number;
          }>;
        };
        collections: import('./types').Collection[];
      };
      payload: {
        slug: string;
      };
    };
    "workspace.entries.all": {
      result: {
        entries: Array<{
          id: string;
          origin: string;
          name: string;
          content: string;
          text_content: string;
          version: number;
          type: 'link' | 'audio' | 'video' | 'image' | 'pdf' | 'interchange' | 'epub' | 'word_document' | 'presentation' | 'spreadsheet' | 'html' | 'markdown' | 'plain_text' | 'archive' | 'code' | 'comment' | 'other';
          parent_id: number;
          file_id?: string | null;
          filesize_bytes: number;
          status: 'queued' | 'processing' | 'completed' | 'failed' | 'canceled' | 'paused';
          queued_at: string;
          created_at: string;
          updated_at: string;
          archived_at: string;
          added_by: {
            first_name: string;
            last_name: string;
            username: string;
          };
          collection: {
            id: string;
            name: string;
            slug: string;
          };
          workspace: {
            id: string;
            name: string;
            slug: string;
          };
          metadata: import('./types').FileMetadata | import('./types').Metadata;
        }>;
        workspace_slug: string;
        pagination: {
          next_page: number | null;
          previous_page: number | null;
          current_page: number;
          total_pages: number;
          total_count: number;
        };
      };
      payload: {
        pagination: {
          page: number;
          per_page: number;
        };
        workspace_slug: string;
      };
    };
    "workspace.members.all": {
      result: {
        members: Array<{
          id: number;
          invite_id?: string | null;
          first_name: string;
          last_name: string;
          email: string;
          role: 'user' | 'admin' | 'guest' | 'owner';
          user: {
            id: string;
          };
          status: 'accepted' | 'pending' | 'declined' | 'revoked' | 'expired';
          created_at: string;
        }>;
        pagination: {
          next_page: number | null;
          previous_page: number | null;
          current_page: number;
          total_pages: number;
          total_count: number;
        };
      };
      payload: {
        workspace_id: string;
        pagination: {
          page: number;
          per_page: number;
        };
      };
    };
    "workspace.invite.find": {
      result: {
        invite: {
          id: string;
          invited: {
            email: string;
          };
          workspace: {
            id: string;
            name: string;
            slug: string;
          };
          inviter: {
            id: number;
            user_id: string;
            first_name: string;
            last_name: string;
            email: string;
            email_verified: boolean;
            username: string;
            avatar_id: string;
            created_at: number;
            last_updated_at: number;
          };
          status: 'accepted' | 'pending' | 'declined' | 'revoked' | 'expired';
          role: 'user' | 'admin' | 'guest' | 'owner';
          invited_at: string;
        };
      };
      payload: {
        invite_id: string;
      };
    };
    "workspace.member.status": {
      result: {
        workspace: {
          id: string;
          name: string;
          slug: string;
          owner_id: number;
          description: string;
          avatar_id: string;
          enable_public_indexing: boolean;
          invite_only: boolean;
          created_at: string;
          collections: Array<{
            id: string;
            name: string;
            slug: string;
            workspace_id: number;
            description: string;
            avatar_id: string;
            created_at: string;
            owner_id: number;
            members_count: number;
            entries_count: number;
          }>;
        };
        status: {
          member_id: number;
          user_id: number;
          role: 'user' | 'admin' | 'guest' | 'owner';
          is_member: boolean;
        };
      };
      payload: {
        workspace_slug: string;
      };
    };
    "collection.entries.all": {
      result: {
        entries: Array<{
          id: string;
          origin: string;
          name: string;
          content: string;
          text_content: string;
          version: number;
          type: 'link' | 'audio' | 'video' | 'image' | 'pdf' | 'interchange' | 'epub' | 'word_document' | 'presentation' | 'spreadsheet' | 'html' | 'markdown' | 'plain_text' | 'archive' | 'code' | 'comment' | 'other';
          parent_id: number;
          file_id?: string | null;
          filesize_bytes: number;
          status: 'queued' | 'processing' | 'completed' | 'failed' | 'canceled' | 'paused';
          queued_at: string;
          created_at: string;
          updated_at: string;
          archived_at: string;
          added_by: {
            first_name: string;
            last_name: string;
            username: string;
          };
          collection: {
            id: string;
            name: string;
            slug: string;
          };
          workspace: {
            id: string;
            name: string;
            slug: string;
          };
          metadata: import('./types').FileMetadata | import('./types').Metadata;
        }>;
        workspace_slug: string;
        pagination: {
          next_page: number | null;
          previous_page: number | null;
          current_page: number;
          total_pages: number;
          total_count: number;
        };
      };
      payload: {
        pagination: {
          page: number;
          per_page: number;
        };
        collection_slug: string;
        workspace_slug: string;
      };
    };
    "collection.member.status": {
      result: {
        collection: {
          id: string;
          name: string;
          slug: string;
          workspace_id: number;
          description: string;
          avatar_id: string;
          created_at: string;
          owner_id: number;
          members_count: number;
          entries_count: number;
        };
        membership_status: {
          member_id: number;
          user_id: number;
          role: 'user' | 'admin' | 'guest' | 'owner';
          is_member: boolean;
        };
        workspace: {
          id: string;
          name: string;
          slug: string;
          owner_id: number;
          description: string;
          avatar_id: string;
          enable_public_indexing: boolean;
          invite_only: boolean;
          created_at: string;
          collections: Array<{
            id: string;
            name: string;
            slug: string;
            workspace_id: number;
            description: string;
            avatar_id: string;
            created_at: string;
            owner_id: number;
            members_count: number;
            entries_count: number;
          }>;
        };
      };
      payload: {
        collection_slug: string;
        workspace_slug: string;
      };
    };
    "collection.members.all": {
      result: {
        members: Array<{
          id: number;
          invite_id?: string | null;
          first_name: string;
          last_name: string;
          email: string;
          role: 'user' | 'admin' | 'guest' | 'owner';
          user: {
            id: string;
          };
          status: 'accepted' | 'pending' | 'declined' | 'revoked' | 'expired';
          created_at: string;
        }>;
        pagination: {
          next_page: number | null;
          previous_page: number | null;
          current_page: number;
          total_pages: number;
          total_count: number;
        };
      };
      payload: {
        collection_id: string;
        workspace_id: string;
        pagination: {
          page: number;
          per_page: number;
        };
      };
    };
    "plugin.source.list": {
      result: {
        sources: Array<{
          id: string;
          workspace_id: number;
          name: string;
          description: string;
          author: string;
          disabled_at: string;
          versioning_strategy: 'commit' | 'tag';
          source_url: string;
          version_id: string;
          sync_status: string;
          last_sync_error: string;
          last_synced_at: string;
          added_at: string;
          updated_at: string;
        }>;
        pagination: {
          next_page: number | null;
          previous_page: number | null;
          current_page: number;
          total_pages: number;
          total_count: number;
        };
      };
      payload: {
        workspace_id: string;
        pagination: {
          page: number;
          per_page: number;
        };
      };
    };
    "plugin.list": {
      result: {
        plugins: Array<{
          identifier: string;
          name: string;
          description: string;
          author: string;
          source: {
            id: string;
            name: string;
            url: string;
          };
          privileges: Array<{
            identifier: string;
            description: string;
          }>;
          targets: Array<string>;
          installed: boolean;
          updatable: boolean;
        }>;
      };
      payload: {
        workspace_id: string;
      };
    };
  };
  mutations: {
    "auth.sign-in": {
      result: {
        email: string;
        requires_email_verification: boolean;
        workspaces: Array<{
          id: string;
          name: string;
          slug: string;
          owner_id: number;
          description: string;
          avatar_id: string;
          enable_public_indexing: boolean;
          invite_only: boolean;
          created_at: string;
          collections: Array<{
            id: string;
            name: string;
            slug: string;
            workspace_id: number;
            description: string;
            avatar_id: string;
            created_at: string;
            owner_id: number;
            members_count: number;
            entries_count: number;
          }>;
        }>;
        mfa: {
          enabled: boolean;
          session_id: string;
        };
        user: {
          id: number;
          user_id: string;
          first_name: string;
          last_name: string;
          email: string;
          email_verified: boolean;
          username: string;
          avatar_id: string;
          created_at: number;
          last_updated_at: number;
        } | null;
      };
      payload: {
        email: string;
        password: string;
      };
    };
    "auth.sign-up": {
      result: {
        user_id: string;
        username: string;
        available_mfa_methods: Array<'email' | 'totp'>;
      };
      payload: {
        first_name: string;
        last_name: string;
        username: string;
        email: string;
        password: string;
      };
    };
    "auth.verify-email": {
      result: {
        email: string;
      };
      payload: {
        email: string;
        token: string;
      };
    };
    "auth.request-password-reset": {
      result: {
        message: string;
      };
      payload: {
        email: string;
        scope: 'reset' | 'change';
      };
    };
    "auth.change-password": {
      result: {
        message: string;
        scope: string;
      };
      payload: {
        email: string;
        token: string;
        current_password: string;
        new_password: string;
        confirm_password: string;
        scope: 'reset' | 'change';
      };
    };
    "auth.request-email-verification": {
      result: string;
      payload: string;
    };
    "mfa.initiate-auth-session": {
      result: {
        session_id: string;
      };
      payload: {
        account_id: string;
        prev_session_id: string;
      };
    };
    "mfa.verify-auth-session": {
      result: {
        message: string;
        workspaces: Array<{
          id: string;
          name: string;
          slug: string;
          owner_id: number;
          description: string;
          avatar_id: string;
          enable_public_indexing: boolean;
          invite_only: boolean;
          created_at: string;
          collections: Array<{
            id: string;
            name: string;
            slug: string;
            workspace_id: number;
            description: string;
            avatar_id: string;
            created_at: string;
            owner_id: number;
            members_count: number;
            entries_count: number;
          }>;
        }>;
        user: {
          id: number;
          user_id: string;
          first_name: string;
          last_name: string;
          email: string;
          email_verified: boolean;
          username: string;
          avatar_id: string;
          created_at: number;
          last_updated_at: number;
        } | null;
      };
      payload: {
        session_id: string;
        code: string;
        use_backup_code: boolean;
      };
    };
    "mfa.resend-email": {
      result: {
        session_id: string;
        message: string;
      };
      payload: {
        session_id: string;
        scope: 'setup' | 'login';
      };
    };
    "auth.sign-out": {
      result: void;
      payload: void;
    };
    "user.request-email-change": {
      result: {
        email: string;
      };
      payload: {
        email: string;
      };
    };
    "user.verify-email-change": {
      result: {
        email: string;
      };
      payload: {
        email: string;
        code: string;
      };
    };
    "mfa.create-email-account": {
      result: {
        session_id: string;
        email: string;
      };
      payload: {
        email: string;
      };
    };
    "mfa.activate-email-account": {
      result: {
        account_id: string;
        backup_codes: Array<string> | null;
      };
      payload: {
        session_id: string;
        token: string;
      };
    };
    "mfa.set-default-account": {
      result: {
        account_id: string;
        name: string;
      };
      payload: string;
    };
    "mfa.regenerate-backup-codes": {
      result: Array<string>;
      payload: void;
    };
    "mfa.start-totp-enrollment": {
      result: {
        session_id: string;
        secret: string;
        image: string;
      };
      payload: string;
    };
    "mfa.complete-totp-enrollment": {
      result: {
        account_id: string;
        backup_codes: Array<string> | null;
      };
      payload: {
        session_id: string;
        code: string;
      };
    };
    "mfa.rename-account": {
      result: {
        account_id: string;
        name: string;
      };
      payload: {
        account_id: string;
        name: string;
      };
    };
    "mfa.delete-account": {
      result: {
        account_id: string;
      };
      payload: {
        account_id: string;
        password: string;
      };
    };
    "user.save-profile": {
      result: {
        id: number;
        user_id: string;
        first_name: string;
        last_name: string;
        email: string;
        email_verified: boolean;
        username: string;
        avatar_id: string;
        created_at: number;
        last_updated_at: number;
      };
      payload: {
        first_name: string;
        last_name: string;
        username: string;
      };
    };
    "workspace.create": {
      result: {
        workspace: {
          id: string;
          name: string;
          slug: string;
          owner_id: number;
          description: string;
          avatar_id: string;
          enable_public_indexing: boolean;
          invite_only: boolean;
          created_at: string;
          collections: Array<{
            id: string;
            name: string;
            slug: string;
            workspace_id: number;
            description: string;
            avatar_id: string;
            created_at: string;
            owner_id: number;
            members_count: number;
            entries_count: number;
          }>;
        };
      };
      payload: {
        name: string;
        slug: string;
        description?: string | null;
      };
    };
    "workspace.details.update": {
      result: {
        workspace: {
          id: string;
          name: string;
          slug: string;
          owner_id: number;
          description: string;
          avatar_id: string;
          enable_public_indexing: boolean;
          invite_only: boolean;
          created_at: string;
          collections: Array<{
            id: string;
            name: string;
            slug: string;
            workspace_id: number;
            description: string;
            avatar_id: string;
            created_at: string;
            owner_id: number;
            members_count: number;
            entries_count: number;
          }>;
        };
      };
      payload: {
        name: string;
        slug: string;
        description?: string | null;
        workspace_id: string;
      };
    };
    "workspace.delete": {
      result: {
        workspace_id: string;
      };
      payload: {
        workspace_id: string;
      };
    };
    "workspace.invite": {
      result: {
        message: string;
        invited_users: Array<string>;
        errors: Record<string, string>;
      };
      payload: {
        emails: Array<string>;
        workspace_id: string;
      };
    };
    "workspace.member.role.update": {
      result: {
        user_id: string;
        role: 'user' | 'admin' | 'owner' | 'guest';
      };
      payload: {
        workspace_id: string;
        user_id: string;
        role: 'user' | 'admin' | 'owner' | 'guest';
      };
    };
    "workspace.invite.status.update": {
      result: {
        status: 'accepted' | 'declined' | 'revoked';
        workspace: {
          id: string;
          name: string;
          slug: string;
          owner_id: number;
          description: string;
          avatar_id: string;
          enable_public_indexing: boolean;
          invite_only: boolean;
          created_at: string;
          collections: Array<{
            id: string;
            name: string;
            slug: string;
            workspace_id: number;
            description: string;
            avatar_id: string;
            created_at: string;
            owner_id: number;
            members_count: number;
            entries_count: number;
          }>;
        } | null;
      };
      payload: {
        workspace_id: string;
        invite_id: string;
        status: 'accepted' | 'declined' | 'revoked';
      };
    };
    "workspace.member.remove": {
      result: {
        first_name: string;
        last_name: string;
        member_id: number;
      };
      payload: {
        email: string;
        workspace_id: string;
      };
    };
    "collection.create": {
      result: {
        workspace_slug: string;
        collection: {
          id: string;
          name: string;
          slug: string;
          workspace_id: number;
          description: string;
          avatar_id: string;
          created_at: string;
          owner_id: number;
          members_count: number;
          entries_count: number;
        };
      };
      payload: {
        workspace_slug: string;
        name: string;
        slug?: string | null;
        description?: string | null;
        assign_all_members: boolean;
      };
    };
    "collection.details.update": {
      result: {
        workspace_slug: string;
        collection: {
          id: string;
          name: string;
          slug: string;
          workspace_id: number;
          description: string;
          avatar_id: string;
          created_at: string;
          owner_id: number;
          members_count: number;
          entries_count: number;
        };
      };
      payload: {
        name: string;
        slug: string;
        description?: string | null;
        collection_id: string;
        workspace_id: string;
      };
    };
    "collection.members.add": {
      result: {
        added_count: number;
      };
      payload: {
        collection_id: string;
        workspace_id: string;
        emails: Array<string>;
      };
    };
    "collection.members.remove": {
      result: {
        removed_count: number;
      };
      payload: {
        collection_id: string;
        workspace_id: string;
        emails: Array<string>;
      };
    };
    "collection.leave": {
      result: string;
      payload: {
        collection_id: string;
        workspace_id: string;
      };
    };
    "collection.delete": {
      result: {
        id: string;
        name: string;
        slug: string;
        owner_id: number;
        description: string;
        avatar_id: string;
        enable_public_indexing: boolean;
        invite_only: boolean;
        created_at: string;
        collections: Array<{
          id: string;
          name: string;
          slug: string;
          workspace_id: number;
          description: string;
          avatar_id: string;
          created_at: string;
          owner_id: number;
          members_count: number;
          entries_count: number;
        }>;
      };
      payload: {
        collection_id: string;
        workspace_id: string;
      };
    };
    "entry.import": {
      result: {
        workspace_id: string;
        collection_id: string;
        entries: Array<{
          id: {
            Bytes: Array<number>;
            Valid: boolean;
          };
          name: string;
          type: string;
        }>;
      };
      payload: {
        collection_id: string;
        workspace_id: string;
        links: Array<string>;
        files: Array<File>;
      };
    };
    "entry.delete": {
      result: {
        deleted_entries: Array<string>;
        message: string;
      };
      payload: {
        workspace_slug: string;
        entry_ids: Array<string>;
      };
    };
    "entry.requeue": {
      result: {
        workspace_slug: string;
        count: number;
      };
      payload: {
        workspace_id: string;
        entry_ids: Array<string>;
      };
    };
    "plugin.source.find": {
      result: {
        source: import('$/lib/server/types').SourceV1;
        plugins: import('$/lib/server/types').PluginV1[];
      };
      payload: {
        workspace_id: string;
        url: string;
      };
    };
    "plugin.source.add": {
      result: {
        source: import('$/lib/server/types').SourceV1;
      };
      payload: {
        workspace_id: string;
        url: string;
      };
    };
    "plugin.source.remove": {
      result: {
        workspace_slug: string;
      };
      payload: {
        workspace_id: string;
        source_id: string;
      };
    };
    "plugin.install": {
      result: {
        plugin_name: string;
        source_name: string;
      };
      payload: {
        workspace_id: string;
        source_id: string;
        name: string;
      };
    };
    "plugin.update": {
      result: {
        plugin_name: string;
        source_name: string;
      };
      payload: {
        workspace_id: string;
        source_id: string;
        name: string;
      };
    };
    "plugin.remove": {
      result: {
        plugin_name: string;
        source_name: string;
      };
      payload: {
        workspace_id: string;
        plugin_id: string;
      };
    };
  };
};


// Create a new HTTP client function with the given fetch options
export function createDefaultHttpClient(fetchOpts: ExtraFetchOpts): HttpClientFn {
  return async (url: string, opts?: RequestOpts): Promise<Response> => {
    return fetch(url, {
      method: opts?.method || "GET",
      headers: opts?.headers || {},
      body: opts?.body || undefined,
      ...fetchOpts,
    });
  };
}

/**
 * ==================== CONTAINERS ====================
 *
 * These classes are used to group query and mutation methods together
 **/
class Queries<CSchema extends ClientSchema = Schema> {
  constructor(private client: Client<CSchema>) {}
  
  /**
   * @procedure ping
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "ping">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async ping(opts?: CallOpts<CSchema, "query", "ping">): Promise<ProcedureResult<CSchema, "query", "ping">> {
    return await this.client.call("query", { ...opts, name: "ping", payload: undefined });
  }

  /**
   * @procedure mfa.load-session
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "mfa.load-session">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async mfaLoadSession(payload: PayloadOf<CSchema, "query", "mfa.load-session">, opts?: CallOpts<CSchema, "query", "mfa.load-session">): Promise<ProcedureResult<CSchema, "query", "mfa.load-session">> {
    return await this.client.call("query", { ...opts, name: "mfa.load-session", payload: payload });
  }

  /**
   * @procedure me
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "me">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async me(opts?: CallOpts<CSchema, "query", "me">): Promise<ProcedureResult<CSchema, "query", "me">> {
    return await this.client.call("query", { ...opts, name: "me", payload: undefined });
  }

  /**
   * @procedure mfa.state
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "mfa.state">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async mfaState(opts?: CallOpts<CSchema, "query", "mfa.state">): Promise<ProcedureResult<CSchema, "query", "mfa.state">> {
    return await this.client.call("query", { ...opts, name: "mfa.state", payload: undefined });
  }

  /**
   * @procedure get-link-metadata
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "get-link-metadata">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async getLinkMetadata(payload: PayloadOf<CSchema, "query", "get-link-metadata">, opts?: CallOpts<CSchema, "query", "get-link-metadata">): Promise<ProcedureResult<CSchema, "query", "get-link-metadata">> {
    return await this.client.call("query", { ...opts, name: "get-link-metadata", payload: payload });
  }

  /**
   * @procedure entry.find
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "entry.find">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async entryFind(payload: PayloadOf<CSchema, "query", "entry.find">, opts?: CallOpts<CSchema, "query", "entry.find">): Promise<ProcedureResult<CSchema, "query", "entry.find">> {
    return await this.client.call("query", { ...opts, name: "entry.find", payload: payload });
  }

  /**
   * @procedure entry.search
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "entry.search">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async entrySearch(payload: PayloadOf<CSchema, "query", "entry.search">, opts?: CallOpts<CSchema, "query", "entry.search">): Promise<ProcedureResult<CSchema, "query", "entry.search">> {
    return await this.client.call("query", { ...opts, name: "entry.search", payload: payload });
  }

  /**
   * @procedure workspace.find
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "workspace.find">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async workspaceFind(payload: PayloadOf<CSchema, "query", "workspace.find">, opts?: CallOpts<CSchema, "query", "workspace.find">): Promise<ProcedureResult<CSchema, "query", "workspace.find">> {
    return await this.client.call("query", { ...opts, name: "workspace.find", payload: payload });
  }

  /**
   * @procedure workspace.entries.all
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "workspace.entries.all">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async workspaceEntriesAll(payload: PayloadOf<CSchema, "query", "workspace.entries.all">, opts?: CallOpts<CSchema, "query", "workspace.entries.all">): Promise<ProcedureResult<CSchema, "query", "workspace.entries.all">> {
    return await this.client.call("query", { ...opts, name: "workspace.entries.all", payload: payload });
  }

  /**
   * @procedure workspace.members.all
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "workspace.members.all">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async workspaceMembersAll(payload: PayloadOf<CSchema, "query", "workspace.members.all">, opts?: CallOpts<CSchema, "query", "workspace.members.all">): Promise<ProcedureResult<CSchema, "query", "workspace.members.all">> {
    return await this.client.call("query", { ...opts, name: "workspace.members.all", payload: payload });
  }

  /**
   * @procedure workspace.invite.find
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "workspace.invite.find">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async workspaceInviteFind(payload: PayloadOf<CSchema, "query", "workspace.invite.find">, opts?: CallOpts<CSchema, "query", "workspace.invite.find">): Promise<ProcedureResult<CSchema, "query", "workspace.invite.find">> {
    return await this.client.call("query", { ...opts, name: "workspace.invite.find", payload: payload });
  }

  /**
   * @procedure workspace.member.status
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "workspace.member.status">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async workspaceMemberStatus(payload: PayloadOf<CSchema, "query", "workspace.member.status">, opts?: CallOpts<CSchema, "query", "workspace.member.status">): Promise<ProcedureResult<CSchema, "query", "workspace.member.status">> {
    return await this.client.call("query", { ...opts, name: "workspace.member.status", payload: payload });
  }

  /**
   * @procedure collection.entries.all
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "collection.entries.all">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async collectionEntriesAll(payload: PayloadOf<CSchema, "query", "collection.entries.all">, opts?: CallOpts<CSchema, "query", "collection.entries.all">): Promise<ProcedureResult<CSchema, "query", "collection.entries.all">> {
    return await this.client.call("query", { ...opts, name: "collection.entries.all", payload: payload });
  }

  /**
   * @procedure collection.member.status
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "collection.member.status">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async collectionMemberStatus(payload: PayloadOf<CSchema, "query", "collection.member.status">, opts?: CallOpts<CSchema, "query", "collection.member.status">): Promise<ProcedureResult<CSchema, "query", "collection.member.status">> {
    return await this.client.call("query", { ...opts, name: "collection.member.status", payload: payload });
  }

  /**
   * @procedure collection.members.all
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "collection.members.all">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async collectionMembersAll(payload: PayloadOf<CSchema, "query", "collection.members.all">, opts?: CallOpts<CSchema, "query", "collection.members.all">): Promise<ProcedureResult<CSchema, "query", "collection.members.all">> {
    return await this.client.call("query", { ...opts, name: "collection.members.all", payload: payload });
  }

  /**
   * @procedure plugin.source.list
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "plugin.source.list">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async pluginSourceList(payload: PayloadOf<CSchema, "query", "plugin.source.list">, opts?: CallOpts<CSchema, "query", "plugin.source.list">): Promise<ProcedureResult<CSchema, "query", "plugin.source.list">> {
    return await this.client.call("query", { ...opts, name: "plugin.source.list", payload: payload });
  }

  /**
   * @procedure plugin.list
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "plugin.list">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async pluginList(payload: PayloadOf<CSchema, "query", "plugin.list">, opts?: CallOpts<CSchema, "query", "plugin.list">): Promise<ProcedureResult<CSchema, "query", "plugin.list">> {
    return await this.client.call("query", { ...opts, name: "plugin.list", payload: payload });
  }
}

class Mutations<CSchema extends ClientSchema = Schema> {
  constructor(private client: Client<CSchema>) {}
  
  /**
   * @procedure auth.sign-in
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "auth.sign-in">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async authSignIn(payload: PayloadOf<CSchema, "mutation", "auth.sign-in">, opts?: CallOpts<CSchema, "mutation", "auth.sign-in">): Promise<ProcedureResult<CSchema, "mutation", "auth.sign-in">> {
    return await this.client.call("mutation", { ...opts, name: "auth.sign-in", payload: payload });
  }

  /**
   * @procedure auth.sign-up
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "auth.sign-up">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async authSignUp(payload: PayloadOf<CSchema, "mutation", "auth.sign-up">, opts?: CallOpts<CSchema, "mutation", "auth.sign-up">): Promise<ProcedureResult<CSchema, "mutation", "auth.sign-up">> {
    return await this.client.call("mutation", { ...opts, name: "auth.sign-up", payload: payload });
  }

  /**
   * @procedure auth.verify-email
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "auth.verify-email">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async authVerifyEmail(payload: PayloadOf<CSchema, "mutation", "auth.verify-email">, opts?: CallOpts<CSchema, "mutation", "auth.verify-email">): Promise<ProcedureResult<CSchema, "mutation", "auth.verify-email">> {
    return await this.client.call("mutation", { ...opts, name: "auth.verify-email", payload: payload });
  }

  /**
   * @procedure auth.request-password-reset
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "auth.request-password-reset">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async authRequestPasswordReset(payload: PayloadOf<CSchema, "mutation", "auth.request-password-reset">, opts?: CallOpts<CSchema, "mutation", "auth.request-password-reset">): Promise<ProcedureResult<CSchema, "mutation", "auth.request-password-reset">> {
    return await this.client.call("mutation", { ...opts, name: "auth.request-password-reset", payload: payload });
  }

  /**
   * @procedure auth.change-password
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "auth.change-password">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async authChangePassword(payload: PayloadOf<CSchema, "mutation", "auth.change-password">, opts?: CallOpts<CSchema, "mutation", "auth.change-password">): Promise<ProcedureResult<CSchema, "mutation", "auth.change-password">> {
    return await this.client.call("mutation", { ...opts, name: "auth.change-password", payload: payload });
  }

  /**
   * @procedure auth.request-email-verification
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "auth.request-email-verification">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async authRequestEmailVerification(payload: PayloadOf<CSchema, "mutation", "auth.request-email-verification">, opts?: CallOpts<CSchema, "mutation", "auth.request-email-verification">): Promise<ProcedureResult<CSchema, "mutation", "auth.request-email-verification">> {
    return await this.client.call("mutation", { ...opts, name: "auth.request-email-verification", payload: payload });
  }

  /**
   * @procedure mfa.initiate-auth-session
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "mfa.initiate-auth-session">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async mfaInitiateAuthSession(payload: PayloadOf<CSchema, "mutation", "mfa.initiate-auth-session">, opts?: CallOpts<CSchema, "mutation", "mfa.initiate-auth-session">): Promise<ProcedureResult<CSchema, "mutation", "mfa.initiate-auth-session">> {
    return await this.client.call("mutation", { ...opts, name: "mfa.initiate-auth-session", payload: payload });
  }

  /**
   * @procedure mfa.verify-auth-session
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "mfa.verify-auth-session">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async mfaVerifyAuthSession(payload: PayloadOf<CSchema, "mutation", "mfa.verify-auth-session">, opts?: CallOpts<CSchema, "mutation", "mfa.verify-auth-session">): Promise<ProcedureResult<CSchema, "mutation", "mfa.verify-auth-session">> {
    return await this.client.call("mutation", { ...opts, name: "mfa.verify-auth-session", payload: payload });
  }

  /**
   * @procedure mfa.resend-email
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "mfa.resend-email">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async mfaResendEmail(payload: PayloadOf<CSchema, "mutation", "mfa.resend-email">, opts?: CallOpts<CSchema, "mutation", "mfa.resend-email">): Promise<ProcedureResult<CSchema, "mutation", "mfa.resend-email">> {
    return await this.client.call("mutation", { ...opts, name: "mfa.resend-email", payload: payload });
  }

  /**
   * @procedure auth.sign-out
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "auth.sign-out">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async authSignOut(opts?: CallOpts<CSchema, "mutation", "auth.sign-out">): Promise<ProcedureResult<CSchema, "mutation", "auth.sign-out">> {
    return await this.client.call("mutation", { ...opts, name: "auth.sign-out", payload: undefined });
  }

  /**
   * @procedure user.request-email-change
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "user.request-email-change">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async userRequestEmailChange(payload: PayloadOf<CSchema, "mutation", "user.request-email-change">, opts?: CallOpts<CSchema, "mutation", "user.request-email-change">): Promise<ProcedureResult<CSchema, "mutation", "user.request-email-change">> {
    return await this.client.call("mutation", { ...opts, name: "user.request-email-change", payload: payload });
  }

  /**
   * @procedure user.verify-email-change
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "user.verify-email-change">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async userVerifyEmailChange(payload: PayloadOf<CSchema, "mutation", "user.verify-email-change">, opts?: CallOpts<CSchema, "mutation", "user.verify-email-change">): Promise<ProcedureResult<CSchema, "mutation", "user.verify-email-change">> {
    return await this.client.call("mutation", { ...opts, name: "user.verify-email-change", payload: payload });
  }

  /**
   * @procedure mfa.create-email-account
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "mfa.create-email-account">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async mfaCreateEmailAccount(payload: PayloadOf<CSchema, "mutation", "mfa.create-email-account">, opts?: CallOpts<CSchema, "mutation", "mfa.create-email-account">): Promise<ProcedureResult<CSchema, "mutation", "mfa.create-email-account">> {
    return await this.client.call("mutation", { ...opts, name: "mfa.create-email-account", payload: payload });
  }

  /**
   * @procedure mfa.activate-email-account
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "mfa.activate-email-account">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async mfaActivateEmailAccount(payload: PayloadOf<CSchema, "mutation", "mfa.activate-email-account">, opts?: CallOpts<CSchema, "mutation", "mfa.activate-email-account">): Promise<ProcedureResult<CSchema, "mutation", "mfa.activate-email-account">> {
    return await this.client.call("mutation", { ...opts, name: "mfa.activate-email-account", payload: payload });
  }

  /**
   * @procedure mfa.set-default-account
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "mfa.set-default-account">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async mfaSetDefaultAccount(payload: PayloadOf<CSchema, "mutation", "mfa.set-default-account">, opts?: CallOpts<CSchema, "mutation", "mfa.set-default-account">): Promise<ProcedureResult<CSchema, "mutation", "mfa.set-default-account">> {
    return await this.client.call("mutation", { ...opts, name: "mfa.set-default-account", payload: payload });
  }

  /**
   * @procedure mfa.regenerate-backup-codes
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "mfa.regenerate-backup-codes">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async mfaRegenerateBackupCodes(opts?: CallOpts<CSchema, "mutation", "mfa.regenerate-backup-codes">): Promise<ProcedureResult<CSchema, "mutation", "mfa.regenerate-backup-codes">> {
    return await this.client.call("mutation", { ...opts, name: "mfa.regenerate-backup-codes", payload: undefined });
  }

  /**
   * @procedure mfa.start-totp-enrollment
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "mfa.start-totp-enrollment">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async mfaStartTotpEnrollment(payload: PayloadOf<CSchema, "mutation", "mfa.start-totp-enrollment">, opts?: CallOpts<CSchema, "mutation", "mfa.start-totp-enrollment">): Promise<ProcedureResult<CSchema, "mutation", "mfa.start-totp-enrollment">> {
    return await this.client.call("mutation", { ...opts, name: "mfa.start-totp-enrollment", payload: payload });
  }

  /**
   * @procedure mfa.complete-totp-enrollment
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "mfa.complete-totp-enrollment">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async mfaCompleteTotpEnrollment(payload: PayloadOf<CSchema, "mutation", "mfa.complete-totp-enrollment">, opts?: CallOpts<CSchema, "mutation", "mfa.complete-totp-enrollment">): Promise<ProcedureResult<CSchema, "mutation", "mfa.complete-totp-enrollment">> {
    return await this.client.call("mutation", { ...opts, name: "mfa.complete-totp-enrollment", payload: payload });
  }

  /**
   * @procedure mfa.rename-account
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "mfa.rename-account">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async mfaRenameAccount(payload: PayloadOf<CSchema, "mutation", "mfa.rename-account">, opts?: CallOpts<CSchema, "mutation", "mfa.rename-account">): Promise<ProcedureResult<CSchema, "mutation", "mfa.rename-account">> {
    return await this.client.call("mutation", { ...opts, name: "mfa.rename-account", payload: payload });
  }

  /**
   * @procedure mfa.delete-account
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "mfa.delete-account">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async mfaDeleteAccount(payload: PayloadOf<CSchema, "mutation", "mfa.delete-account">, opts?: CallOpts<CSchema, "mutation", "mfa.delete-account">): Promise<ProcedureResult<CSchema, "mutation", "mfa.delete-account">> {
    return await this.client.call("mutation", { ...opts, name: "mfa.delete-account", payload: payload });
  }

  /**
   * @procedure user.save-profile
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "user.save-profile">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async userSaveProfile(payload: PayloadOf<CSchema, "mutation", "user.save-profile">, opts?: CallOpts<CSchema, "mutation", "user.save-profile">): Promise<ProcedureResult<CSchema, "mutation", "user.save-profile">> {
    return await this.client.call("mutation", { ...opts, name: "user.save-profile", payload: payload });
  }

  /**
   * @procedure workspace.create
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "workspace.create">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async workspaceCreate(payload: PayloadOf<CSchema, "mutation", "workspace.create">, opts?: CallOpts<CSchema, "mutation", "workspace.create">): Promise<ProcedureResult<CSchema, "mutation", "workspace.create">> {
    return await this.client.call("mutation", { ...opts, name: "workspace.create", payload: payload });
  }

  /**
   * @procedure workspace.details.update
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "workspace.details.update">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async workspaceDetailsUpdate(payload: PayloadOf<CSchema, "mutation", "workspace.details.update">, opts?: CallOpts<CSchema, "mutation", "workspace.details.update">): Promise<ProcedureResult<CSchema, "mutation", "workspace.details.update">> {
    return await this.client.call("mutation", { ...opts, name: "workspace.details.update", payload: payload });
  }

  /**
   * @procedure workspace.delete
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "workspace.delete">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async workspaceDelete(payload: PayloadOf<CSchema, "mutation", "workspace.delete">, opts?: CallOpts<CSchema, "mutation", "workspace.delete">): Promise<ProcedureResult<CSchema, "mutation", "workspace.delete">> {
    return await this.client.call("mutation", { ...opts, name: "workspace.delete", payload: payload });
  }

  /**
   * @procedure workspace.invite
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "workspace.invite">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async workspaceInvite(payload: PayloadOf<CSchema, "mutation", "workspace.invite">, opts?: CallOpts<CSchema, "mutation", "workspace.invite">): Promise<ProcedureResult<CSchema, "mutation", "workspace.invite">> {
    return await this.client.call("mutation", { ...opts, name: "workspace.invite", payload: payload });
  }

  /**
   * @procedure workspace.member.role.update
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "workspace.member.role.update">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async workspaceMemberRoleUpdate(payload: PayloadOf<CSchema, "mutation", "workspace.member.role.update">, opts?: CallOpts<CSchema, "mutation", "workspace.member.role.update">): Promise<ProcedureResult<CSchema, "mutation", "workspace.member.role.update">> {
    return await this.client.call("mutation", { ...opts, name: "workspace.member.role.update", payload: payload });
  }

  /**
   * @procedure workspace.invite.status.update
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "workspace.invite.status.update">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async workspaceInviteStatusUpdate(payload: PayloadOf<CSchema, "mutation", "workspace.invite.status.update">, opts?: CallOpts<CSchema, "mutation", "workspace.invite.status.update">): Promise<ProcedureResult<CSchema, "mutation", "workspace.invite.status.update">> {
    return await this.client.call("mutation", { ...opts, name: "workspace.invite.status.update", payload: payload });
  }

  /**
   * @procedure workspace.member.remove
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "workspace.member.remove">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async workspaceMemberRemove(payload: PayloadOf<CSchema, "mutation", "workspace.member.remove">, opts?: CallOpts<CSchema, "mutation", "workspace.member.remove">): Promise<ProcedureResult<CSchema, "mutation", "workspace.member.remove">> {
    return await this.client.call("mutation", { ...opts, name: "workspace.member.remove", payload: payload });
  }

  /**
   * @procedure collection.create
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "collection.create">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async collectionCreate(payload: PayloadOf<CSchema, "mutation", "collection.create">, opts?: CallOpts<CSchema, "mutation", "collection.create">): Promise<ProcedureResult<CSchema, "mutation", "collection.create">> {
    return await this.client.call("mutation", { ...opts, name: "collection.create", payload: payload });
  }

  /**
   * @procedure collection.details.update
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "collection.details.update">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async collectionDetailsUpdate(payload: PayloadOf<CSchema, "mutation", "collection.details.update">, opts?: CallOpts<CSchema, "mutation", "collection.details.update">): Promise<ProcedureResult<CSchema, "mutation", "collection.details.update">> {
    return await this.client.call("mutation", { ...opts, name: "collection.details.update", payload: payload });
  }

  /**
   * @procedure collection.members.add
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "collection.members.add">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async collectionMembersAdd(payload: PayloadOf<CSchema, "mutation", "collection.members.add">, opts?: CallOpts<CSchema, "mutation", "collection.members.add">): Promise<ProcedureResult<CSchema, "mutation", "collection.members.add">> {
    return await this.client.call("mutation", { ...opts, name: "collection.members.add", payload: payload });
  }

  /**
   * @procedure collection.members.remove
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "collection.members.remove">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async collectionMembersRemove(payload: PayloadOf<CSchema, "mutation", "collection.members.remove">, opts?: CallOpts<CSchema, "mutation", "collection.members.remove">): Promise<ProcedureResult<CSchema, "mutation", "collection.members.remove">> {
    return await this.client.call("mutation", { ...opts, name: "collection.members.remove", payload: payload });
  }

  /**
   * @procedure collection.leave
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "collection.leave">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async collectionLeave(payload: PayloadOf<CSchema, "mutation", "collection.leave">, opts?: CallOpts<CSchema, "mutation", "collection.leave">): Promise<ProcedureResult<CSchema, "mutation", "collection.leave">> {
    return await this.client.call("mutation", { ...opts, name: "collection.leave", payload: payload });
  }

  /**
   * @procedure collection.delete
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "collection.delete">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async collectionDelete(payload: PayloadOf<CSchema, "mutation", "collection.delete">, opts?: CallOpts<CSchema, "mutation", "collection.delete">): Promise<ProcedureResult<CSchema, "mutation", "collection.delete">> {
    return await this.client.call("mutation", { ...opts, name: "collection.delete", payload: payload });
  }

  /**
   * @procedure entry.import
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "entry.import">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async entryImport(payload: PayloadOf<CSchema, "mutation", "entry.import">, opts?: CallOpts<CSchema, "mutation", "entry.import">): Promise<ProcedureResult<CSchema, "mutation", "entry.import">> {
    return await this.client.call("mutation", { ...opts, name: "entry.import", payload: payload });
  }

  /**
   * @procedure entry.delete
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "entry.delete">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async entryDelete(payload: PayloadOf<CSchema, "mutation", "entry.delete">, opts?: CallOpts<CSchema, "mutation", "entry.delete">): Promise<ProcedureResult<CSchema, "mutation", "entry.delete">> {
    return await this.client.call("mutation", { ...opts, name: "entry.delete", payload: payload });
  }

  /**
   * @procedure entry.requeue
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "entry.requeue">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async entryRequeue(payload: PayloadOf<CSchema, "mutation", "entry.requeue">, opts?: CallOpts<CSchema, "mutation", "entry.requeue">): Promise<ProcedureResult<CSchema, "mutation", "entry.requeue">> {
    return await this.client.call("mutation", { ...opts, name: "entry.requeue", payload: payload });
  }

  /**
   * @procedure plugin.source.find
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "plugin.source.find">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async pluginSourceFind(payload: PayloadOf<CSchema, "mutation", "plugin.source.find">, opts?: CallOpts<CSchema, "mutation", "plugin.source.find">): Promise<ProcedureResult<CSchema, "mutation", "plugin.source.find">> {
    return await this.client.call("mutation", { ...opts, name: "plugin.source.find", payload: payload });
  }

  /**
   * @procedure plugin.source.add
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "plugin.source.add">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async pluginSourceAdd(payload: PayloadOf<CSchema, "mutation", "plugin.source.add">, opts?: CallOpts<CSchema, "mutation", "plugin.source.add">): Promise<ProcedureResult<CSchema, "mutation", "plugin.source.add">> {
    return await this.client.call("mutation", { ...opts, name: "plugin.source.add", payload: payload });
  }

  /**
   * @procedure plugin.source.remove
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "plugin.source.remove">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async pluginSourceRemove(payload: PayloadOf<CSchema, "mutation", "plugin.source.remove">, opts?: CallOpts<CSchema, "mutation", "plugin.source.remove">): Promise<ProcedureResult<CSchema, "mutation", "plugin.source.remove">> {
    return await this.client.call("mutation", { ...opts, name: "plugin.source.remove", payload: payload });
  }

  /**
   * @procedure plugin.install
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "plugin.install">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async pluginInstall(payload: PayloadOf<CSchema, "mutation", "plugin.install">, opts?: CallOpts<CSchema, "mutation", "plugin.install">): Promise<ProcedureResult<CSchema, "mutation", "plugin.install">> {
    return await this.client.call("mutation", { ...opts, name: "plugin.install", payload: payload });
  }

  /**
   * @procedure plugin.update
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "plugin.update">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async pluginUpdate(payload: PayloadOf<CSchema, "mutation", "plugin.update">, opts?: CallOpts<CSchema, "mutation", "plugin.update">): Promise<ProcedureResult<CSchema, "mutation", "plugin.update">> {
    return await this.client.call("mutation", { ...opts, name: "plugin.update", payload: payload });
  }

  /**
   * @procedure plugin.remove
   *
   * @returns Promise<ProcedureResult<CSchema, "query", "plugin.remove">>
   * @throws {ProcedureCallError} if the procedure call fails
   **/
  async pluginRemove(payload: PayloadOf<CSchema, "mutation", "plugin.remove">, opts?: CallOpts<CSchema, "mutation", "plugin.remove">): Promise<ProcedureResult<CSchema, "mutation", "plugin.remove">> {
    return await this.client.call("mutation", { ...opts, name: "plugin.remove", payload: payload });
  }
}

/** ==================== CLIENT ==================== **/
class Client<CSchema extends ClientSchema = Schema> {
  private endpoint: string;
  private clientFn: HttpClientFn;

  public readonly queries: Queries<CSchema>;
  public readonly mutations: Mutations<CSchema>;

  public constructor(opts: ClientOpts) {
    if (!opts.endpoint) {
      throw new Error("An endpoint is required to create a new client");
    }

    this.endpoint = opts.endpoint;
    this.clientFn = opts.clientFn || createDefaultHttpClient(opts.fetchOpts || {});

    this.queries = new Queries<CSchema>(this);
    this.mutations = new Mutations<CSchema>(this);
  }

  // Create a new client instance
  // deno-lint-ignore no-misused-new
  public static new<CSchema extends ClientSchema = Schema>(opts: ClientOpts): Client<CSchema> {
    return new Client<CSchema>(opts);
  }

  // Get the client's endpoint
  public getEndpoint(): string {
    return this.endpoint;
  }

  /**
   * @param {PType} type The type of the procedure to call
   * @param {RawCallOpts<CSchema, PType, PName>} opts The options for the procedure call
   * @returns Promise<ProcedureResult<CSchema, PType, PName>>
   *
   * @description Manually call a robin procedure; this is a low-level function that should not be used directly unless absolutely necessary
   * @throws {ProcedureCallError} if the procedure call fails
   */
  async call<PType extends ProcedureType, PName extends keyof SchemaBasedOnType<CSchema, PType>>(
    type: PType,
    opts: RawCallOpts<CSchema, PType, PName>
  ): Promise<ProcedureResult<CSchema, PType, PName>> {
    try {
      const url = this.makeRequestUrl(type, String(opts.name));

      const requestOpts: RequestOpts = {
        method: "POST",
        body: opts.payload ? JSON.stringify({d: opts.payload}) : undefined,
        headers: {
          "Content-Type": "application/json",
          ...opts.extraHeaders,
        },
      };

      const response = await this.clientFn(url, requestOpts);

      if (!response.ok) {
        let err: unknown = `Failed to call procedure \`${String(opts.name)}\` with status code ${response.status}`;

        // Attempt to parse the response body as JSON to extract the error message
        try {
          const data = (await response.json()) as ServerResponse<ResultOf<CSchema, PType, PName>>;
          if(!!data && data?.error) {
            err = data?.error;
          }
        } catch(_e: unknown) {
          /* Ignore errors here and just throw anyway */
        }
        throw new ProcedureCallError(err, String(opts.name));
      }

      const data = (await response.json()) as ServerResponse<ResultOf<CSchema, PType, PName>>;
      if (!data.ok) {
        throw new ProcedureCallError(data?.error || "An unknown error occurred", String(opts.name)); 
      }

      return data?.data as ResultOf<CSchema, PType, PName>;
    } catch (e: unknown) {
      if (e instanceof ProcedureCallError) {
        throw e;
      }

      const message = Object.prototype.hasOwnProperty.call(e, "message") ? (e as {message: unknown}).message : "An unknown error occurred";
      throw new ProcedureCallError(message, String(opts.name), e as Error);
    }
  }

  /**
   * @param {PName} name The name of the query procedure to call
   * @param {PayloadOf<CSchema, "query", PName>} payload The payload to send to the query procedure
   * @param {CallOpts<CSchema, "query", PName>} opts The options for the query procedure call
   * @returns Promise<ProcedureResult<CSchema, "query", PName>>
   *
   * @description Manually call a robin query procedure
   * @throws {ProcedureCallError} if the procedure call fails
   */
  async query<PName extends keyof SchemaBasedOnType<CSchema, "query">>(
    name: PName,
    payload: PayloadOf<CSchema, "query", PName>,
    opts?: CallOpts<CSchema, "query", PName>
  ): Promise<ProcedureResult<CSchema, "query", PName>> {
    opts = opts || {};
    return await this.call("query", { name, payload, ...opts });
  }

  /**
   * @param {PName} name The name of the mutation procedure to call
   * @param {PayloadOf<CSchema, "mutation", PName>} payload The payload to send to the mutation procedure
   * @param {CallOpts<CSchema, "mutation", PName>} opts The options for the mutation procedure call
   * @returns Promise<ProcedureResult<CSchema, "mutation", PName>>
   *
   * @description Manually call a robin mutation procedure
   * @throws {ProcedureCallError} if the procedure call fails
   */
  async mutate<PName extends keyof SchemaBasedOnType<CSchema, "mutation">>(
    name: PName,
    payload: PayloadOf<CSchema, "mutation", PName>,
    opts?: CallOpts<CSchema, "mutation", PName>
  ): Promise<ProcedureResult<CSchema, "mutation", PName>> {
    opts = opts || {};
    return await this.call("mutation", { name, payload, ...opts });
  }

  private makeRequestUrl(type: ProcedureType, name: string): string {
    const procType = type === "query" ? "q" : "m";
    return `${this.endpoint}?__proc=${procType}__${name}`;
  }
}

// Custom error class for procedure call errors
export class ProcedureCallError extends Error {
  // The actual error message from the server - in most cases, this will be a string, but it can be anything
  public details: unknown;

  // The name of the procedure that caused this error
  public procedureName: string;

  // The previous error that caused this error, if any
  public previousError: Error | null;

  public constructor(message: unknown, procedureName: string, originalError: Error | null = null) {
    super(typeof message === "string" ? message : "A procedure call error occurred, see the `details` property for more information");
    this.name = "ProcedureCallError";
    this.details = message;
    this.procedureName = procedureName;
    this.previousError = originalError;
  }

  public toString(): string {
    return `${this.name}: ${this.message}`;
  }
}

export default Client;
