// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: collection.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"go.trulyao.dev/hubble/web/pkg/rbac"
)

const addMembersToCollection = `-- name: AddMembersToCollection :many
insert into collection_members (collection_id, user_id, bitmask_role)
select c.id, u.id, $1
from collections c
join workspace_members wm ON wm.workspace_id = c.workspace_id
join users u ON u.id = wm.user_id -- this is here for further validation (e.g. that the user has not been deleted)
	where (c.id = $2 or c.public_id = $3)
		and wm.user_id != c.owner_id -- don't add owner
		and u.email = any($4::text[])
		and wm.deleted_at is null
		and c.deleted_at is null
		and u.deleted_at is null
on conflict (collection_id, user_id)
	do update set
		deleted_at = null,
		bitmask_role = EXCLUDED.bitmask_role
	where collection_members.deleted_at is not null -- only restore the ones that were deleted instead of accidentally overwriting roles
returning id, collection_id, user_id, extra_permissions, created_at, updated_at, deleted_at, bitmask_role
`

type AddMembersToCollectionParams struct {
	UserRole           rbac.Role   `json:"user_role"`
	CollectionID       int32       `json:"collection_id"`
	CollectionPublicID pgtype.UUID `json:"collection_public_id"`
	Emails             []string    `json:"emails"`
}

// Add members to a collection from the workspace members list using their email
// address. IF they are already in the collection, update their role and restore them
func (q *Queries) AddMembersToCollection(ctx context.Context, arg AddMembersToCollectionParams) ([]CollectionMember, error) {
	rows, err := q.db.Query(ctx, addMembersToCollection,
		arg.UserRole,
		arg.CollectionID,
		arg.CollectionPublicID,
		arg.Emails,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CollectionMember{}
	for rows.Next() {
		var i CollectionMember
		if err := rows.Scan(
			&i.ID,
			&i.CollectionID,
			&i.UserID,
			&i.ExtraPermissions,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.BitmaskRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const assignAllWorkspaceMembersToCollection = `-- name: AssignAllWorkspaceMembersToCollection :exec
insert into collection_members (collection_id, user_id, bitmask_role)
select $1, user_id, $2
from workspace_members where
    workspace_members.user_id != $3
    and workspace_id = $4
    and deleted_at is null
on conflict (collection_id, user_id)
    do update set deleted_at = null, bitmask_role = EXCLUDED.bitmask_role
`

type AssignAllWorkspaceMembersToCollectionParams struct {
	CollectionID int32     `json:"collection_id"`
	Role         rbac.Role `json:"role"`
	OwnerID      int32     `json:"owner_id"`
	WorkspaceID  int32     `json:"workspace_id"`
}

func (q *Queries) AssignAllWorkspaceMembersToCollection(ctx context.Context, arg AssignAllWorkspaceMembersToCollectionParams) error {
	_, err := q.db.Exec(ctx, assignAllWorkspaceMembersToCollection,
		arg.CollectionID,
		arg.Role,
		arg.OwnerID,
		arg.WorkspaceID,
	)
	return err
}

const collectionNameExists = `-- name: CollectionNameExists :one
select count(id) > 0 as exists
from collections
where
    workspace_id = $1
    and lower(name) = lower($2)
    and deleted_at is null
`

type CollectionNameExistsParams struct {
	WorkspaceID    int32  `json:"workspace_id"`
	CollectionName string `json:"collection_name"`
}

func (q *Queries) CollectionNameExists(ctx context.Context, arg CollectionNameExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, collectionNameExists, arg.WorkspaceID, arg.CollectionName)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const collectionSlugExists = `-- name: CollectionSlugExists :one
select count(id) > 0 as exists
from collections
where workspace_id = $1 and slug = $2 and deleted_at is null
`

type CollectionSlugExistsParams struct {
	WorkspaceID int32       `json:"workspace_id"`
	Slug        pgtype.Text `json:"slug"`
}

func (q *Queries) CollectionSlugExists(ctx context.Context, arg CollectionSlugExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, collectionSlugExists, arg.WorkspaceID, arg.Slug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createCollection = `-- name: CreateCollection :one
insert into collections
(workspace_id, name, description, slug, owner_id)
values ($1, $2, $3, $4, $5)
returning id, public_id, name, workspace_id, description, avatar_id, created_at, updated_at, deleted_at, slug, owner_id
`

type CreateCollectionParams struct {
	WorkspaceID int32       `json:"workspace_id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Slug        pgtype.Text `json:"slug"`
	OwnerID     int32       `json:"owner_id"`
}

func (q *Queries) CreateCollection(ctx context.Context, arg CreateCollectionParams) (Collection, error) {
	row := q.db.QueryRow(ctx, createCollection,
		arg.WorkspaceID,
		arg.Name,
		arg.Description,
		arg.Slug,
		arg.OwnerID,
	)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.WorkspaceID,
		&i.Description,
		&i.AvatarID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Slug,
		&i.OwnerID,
	)
	return i, err
}

const createCollectionMember = `-- name: CreateCollectionMember :exec
insert into collection_members (collection_id, user_id, bitmask_role)
values ($1, $2, $3)
on conflict (collection_id, user_id)
    do update set deleted_at = null, bitmask_role = EXCLUDED.bitmask_role
`

type CreateCollectionMemberParams struct {
	CollectionID int32     `json:"collection_id"`
	UserID       int32     `json:"user_id"`
	BitmaskRole  rbac.Role `json:"bitmask_role"`
}

// Create a collection member. If the user already exists in the collection and was
// deleted, restore them.
func (q *Queries) CreateCollectionMember(ctx context.Context, arg CreateCollectionMemberParams) error {
	_, err := q.db.Exec(ctx, createCollectionMember, arg.CollectionID, arg.UserID, arg.BitmaskRole)
	return err
}

const findCollectionIdByPublicId = `-- name: FindCollectionIdByPublicId :one
select c.id::integer
from collections c
right join workspaces w on w.id = c.workspace_id
where w.public_id = $1 and c.public_id = $2 and c.deleted_at is null
`

type FindCollectionIdByPublicIdParams struct {
	WorkspaceID pgtype.UUID `json:"workspace_id"`
	PublicID    pgtype.UUID `json:"public_id"`
}

func (q *Queries) FindCollectionIdByPublicId(ctx context.Context, arg FindCollectionIdByPublicIdParams) (int32, error) {
	row := q.db.QueryRow(ctx, findCollectionIdByPublicId, arg.WorkspaceID, arg.PublicID)
	var c_id int32
	err := row.Scan(&c_id)
	return c_id, err
}

const findCollectionMember = `-- name: FindCollectionMember :one
select cm.id, cm.collection_id, cm.user_id, cm.extra_permissions, cm.created_at, cm.updated_at, cm.deleted_at, cm.bitmask_role
from collection_members cm
join collections c on c.id = cm.collection_id
join workspaces w on w.id = c.workspace_id
where
    (c.slug = $1 or c.public_id = $2)
    and (w.slug = $3 or w.public_id = $4)
    and cm.user_id = $5
    and c.deleted_at is null
    and cm.deleted_at is null
`

type FindCollectionMemberParams struct {
	CollectionSlug     pgtype.Text `json:"collection_slug"`
	CollectionPublicID pgtype.UUID `json:"collection_public_id"`
	WorkspaceSlug      pgtype.Text `json:"workspace_slug"`
	WorkspacePublicID  pgtype.UUID `json:"workspace_public_id"`
	UserID             int32       `json:"user_id"`
}

type FindCollectionMemberRow struct {
	CollectionMember CollectionMember `json:"collection_member"`
}

func (q *Queries) FindCollectionMember(ctx context.Context, arg FindCollectionMemberParams) (FindCollectionMemberRow, error) {
	row := q.db.QueryRow(ctx, findCollectionMember,
		arg.CollectionSlug,
		arg.CollectionPublicID,
		arg.WorkspaceSlug,
		arg.WorkspacePublicID,
		arg.UserID,
	)
	var i FindCollectionMemberRow
	err := row.Scan(
		&i.CollectionMember.ID,
		&i.CollectionMember.CollectionID,
		&i.CollectionMember.UserID,
		&i.CollectionMember.ExtraPermissions,
		&i.CollectionMember.CreatedAt,
		&i.CollectionMember.UpdatedAt,
		&i.CollectionMember.DeletedAt,
		&i.CollectionMember.BitmaskRole,
	)
	return i, err
}

const findCollectionMembers = `-- name: FindCollectionMembers :many
with
    members as (
        select
            cm.id,
            u.id as user_id,
            u.public_id as public_user_id,
            u.first_name,
            u.last_name,
            u.email,
            cm.bitmask_role as role,
            cm.created_at,
            'accepted' as status,
            '' as invite_id
        from collection_members cm
        join users u on u.id = cm.user_id
        join collections c on c.id = cm.collection_id
        join workspaces w on w.id = c.workspace_id
        where
            (w.public_id = $3 or w.slug = $4)
            and (c.public_id = $5 or c.slug = $6)
            and cm.deleted_at is null
            and w.deleted_at is null
            and u.deleted_at is null
            and c.deleted_at is null
    )
select id, user_id, public_user_id, first_name, last_name, email, role, created_at, status, invite_id, count(*) over () as total_count
from members
limit $1
offset $2
`

type FindCollectionMembersParams struct {
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
	WorkspaceID    pgtype.UUID `json:"workspace_id"`
	WorkspaceSlug  pgtype.Text `json:"workspace_slug"`
	CollectionID   pgtype.UUID `json:"collection_id"`
	CollectionSlug pgtype.Text `json:"collection_slug"`
}

type FindCollectionMembersRow struct {
	ID           int32              `json:"id"`
	UserID       int32              `json:"user_id"`
	PublicUserID pgtype.UUID        `json:"public_user_id"`
	FirstName    string             `json:"first_name"`
	LastName     string             `json:"last_name"`
	Email        string             `json:"email"`
	Role         int32              `json:"role"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	Status       string             `json:"status"`
	InviteID     string             `json:"invite_id"`
	TotalCount   int64              `json:"total_count"`
}

func (q *Queries) FindCollectionMembers(ctx context.Context, arg FindCollectionMembersParams) ([]FindCollectionMembersRow, error) {
	rows, err := q.db.Query(ctx, findCollectionMembers,
		arg.Limit,
		arg.Offset,
		arg.WorkspaceID,
		arg.WorkspaceSlug,
		arg.CollectionID,
		arg.CollectionSlug,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindCollectionMembersRow{}
	for rows.Next() {
		var i FindCollectionMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PublicUserID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Role,
			&i.CreatedAt,
			&i.Status,
			&i.InviteID,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findCollectionWithMembershipStatus = `-- name: FindCollectionWithMembershipStatus :one
select
    c.id, c.public_id, c.name, c.workspace_id, c.description, c.avatar_id, c.created_at, c.updated_at, c.deleted_at, c.slug, c.owner_id,
    w.id, w.public_id, w.display_name, w.owner_id, w.description, w.avatar_id, w.enable_public_indexing, w.invite_only, w.created_at, w.updated_at, w.deleted_at, w.slug,
    (cm.id is not null and cm.deleted_at is null)::bool as is_member,
    -- remove the role if the user has been deleted
    case
        when (cm.id is not null and cm.deleted_at is null) then cm.bitmask_role else 0
    end as role,
    cm.id as member_id,
    cm.user_id as member_user_id
from collections c
left join collection_members cm on cm.collection_id = c.id and cm.user_id = $1
left join workspaces w on w.id = c.workspace_id
where
    (w.public_id = $2 or w.slug = $3)
    and (c.public_id = $4 or c.slug = $5)
    and c.deleted_at is null
    and w.deleted_at is null
`

type FindCollectionWithMembershipStatusParams struct {
	UserID             int32       `json:"user_id"`
	WorkspacePublicID  pgtype.UUID `json:"workspace_public_id"`
	WorkspaceSlug      pgtype.Text `json:"workspace_slug"`
	CollectionPublicID pgtype.UUID `json:"collection_public_id"`
	CollectionSlug     pgtype.Text `json:"collection_slug"`
}

type FindCollectionWithMembershipStatusRow struct {
	Collection   Collection  `json:"collection"`
	Workspace    Workspace   `json:"workspace"`
	IsMember     bool        `json:"is_member"`
	Role         int32       `json:"role"`
	MemberID     pgtype.Int4 `json:"member_id"`
	MemberUserID pgtype.Int4 `json:"member_user_id"`
}

// Find a collection by its public_id or slug and check if the user has permissions to
// access it
func (q *Queries) FindCollectionWithMembershipStatus(ctx context.Context, arg FindCollectionWithMembershipStatusParams) (FindCollectionWithMembershipStatusRow, error) {
	row := q.db.QueryRow(ctx, findCollectionWithMembershipStatus,
		arg.UserID,
		arg.WorkspacePublicID,
		arg.WorkspaceSlug,
		arg.CollectionPublicID,
		arg.CollectionSlug,
	)
	var i FindCollectionWithMembershipStatusRow
	err := row.Scan(
		&i.Collection.ID,
		&i.Collection.PublicID,
		&i.Collection.Name,
		&i.Collection.WorkspaceID,
		&i.Collection.Description,
		&i.Collection.AvatarID,
		&i.Collection.CreatedAt,
		&i.Collection.UpdatedAt,
		&i.Collection.DeletedAt,
		&i.Collection.Slug,
		&i.Collection.OwnerID,
		&i.Workspace.ID,
		&i.Workspace.PublicID,
		&i.Workspace.DisplayName,
		&i.Workspace.OwnerID,
		&i.Workspace.Description,
		&i.Workspace.AvatarID,
		&i.Workspace.EnablePublicIndexing,
		&i.Workspace.InviteOnly,
		&i.Workspace.CreatedAt,
		&i.Workspace.UpdatedAt,
		&i.Workspace.DeletedAt,
		&i.Workspace.Slug,
		&i.IsMember,
		&i.Role,
		&i.MemberID,
		&i.MemberUserID,
	)
	return i, err
}

const findCollectionsByWorkspaceAndUser = `-- name: FindCollectionsByWorkspaceAndUser :many
with
    members_count as (
        select collection_id, count(id) as count
        from collection_members
        group by collection_id
    ),
    entries as (
        select collection_id, count(id) as count from entries group by collection_id
    )
select c.id, c.public_id, c.name, c.workspace_id, c.description, c.avatar_id, c.created_at, c.updated_at, c.deleted_at, c.slug, c.owner_id, coalesce(mc.count, 0) as member_count, coalesce(e.count, 0) as entry_count
from collections c
right join collection_members cm on cm.collection_id = c.id
left join entries e on e.collection_id = c.id
left join members_count mc on mc.collection_id = c.id
where
    cm.user_id = $1
    and c.workspace_id = $2
    and c.deleted_at is null
    and cm.deleted_at is null
order by c.name asc
`

type FindCollectionsByWorkspaceAndUserParams struct {
	UserID      int32 `json:"user_id"`
	WorkspaceID int32 `json:"workspace_id"`
}

type FindCollectionsByWorkspaceAndUserRow struct {
	ID          pgtype.Int4        `json:"id"`
	PublicID    pgtype.UUID        `json:"public_id"`
	Name        pgtype.Text        `json:"name"`
	WorkspaceID pgtype.Int4        `json:"workspace_id"`
	Description pgtype.Text        `json:"description"`
	AvatarID    pgtype.Text        `json:"avatar_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
	Slug        pgtype.Text        `json:"slug"`
	OwnerID     pgtype.Int4        `json:"owner_id"`
	MemberCount int64              `json:"member_count"`
	EntryCount  int64              `json:"entry_count"`
}

func (q *Queries) FindCollectionsByWorkspaceAndUser(ctx context.Context, arg FindCollectionsByWorkspaceAndUserParams) ([]FindCollectionsByWorkspaceAndUserRow, error) {
	rows, err := q.db.Query(ctx, findCollectionsByWorkspaceAndUser, arg.UserID, arg.WorkspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindCollectionsByWorkspaceAndUserRow{}
	for rows.Next() {
		var i FindCollectionsByWorkspaceAndUserRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.WorkspaceID,
			&i.Description,
			&i.AvatarID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Slug,
			&i.OwnerID,
			&i.MemberCount,
			&i.EntryCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUserCollectionsWithWorkspaceOwner = `-- name: FindUserCollectionsWithWorkspaceOwner :many
with
    -- get all the target user's owned collections
    user_collections as (
        select c.id, c.workspace_id, c.owner_id
        from collections c
        join collection_members cm on cm.collection_id = c.id
        where
            cm.user_id = $1
            and c.workspace_id = $2
            and c.owner_id = cm.user_id
            and c.deleted_at is null
    )
select distinct u.id
from user_collections u
join collection_members cm on u.id = cm.collection_id
join workspaces w on u.workspace_id = w.id
where w.owner_id = cm.user_id and cm.deleted_at is null and w.deleted_at is null
`

type FindUserCollectionsWithWorkspaceOwnerParams struct {
	UserID      int32 `json:"user_id"`
	WorkspaceID int32 `json:"workspace_id"`
}

// Find all collections that the target user owns and thw workspace owner is in too
func (q *Queries) FindUserCollectionsWithWorkspaceOwner(ctx context.Context, arg FindUserCollectionsWithWorkspaceOwnerParams) ([]int32, error) {
	rows, err := q.db.Query(ctx, findUserCollectionsWithWorkspaceOwner, arg.UserID, arg.WorkspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int32{}
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const leaveCollection = `-- name: LeaveCollection :exec
update collection_members
set deleted_at = now()
where collection_id = $1
    and user_id = $2
    and deleted_at is null
`

type LeaveCollectionParams struct {
	CollectionID int32 `json:"collection_id"`
	UserID       int32 `json:"user_id"`
}

// Remove the user from the collection
func (q *Queries) LeaveCollection(ctx context.Context, arg LeaveCollectionParams) error {
	_, err := q.db.Exec(ctx, leaveCollection, arg.CollectionID, arg.UserID)
	return err
}

const markCollectionAsDeleted = `-- name: MarkCollectionAsDeleted :exec
update collections
set deleted_at = now()
where
	(id = $1 or public_id = $2)
	and deleted_at is null
`

type MarkCollectionAsDeletedParams struct {
	CollectionID       int32       `json:"collection_id"`
	CollectionPublicID pgtype.UUID `json:"collection_public_id"`
}

// Mark a collection as deleted
func (q *Queries) MarkCollectionAsDeleted(ctx context.Context, arg MarkCollectionAsDeletedParams) error {
	_, err := q.db.Exec(ctx, markCollectionAsDeleted, arg.CollectionID, arg.CollectionPublicID)
	return err
}

const markUsersCollectionsAsDeleted = `-- name: MarkUsersCollectionsAsDeleted :exec
update collections
set deleted_at = now()
where owner_id = $1
    and workspace_id = $2
    and deleted_at is null
`

type MarkUsersCollectionsAsDeletedParams struct {
	UserID      int32 `json:"user_id"`
	WorkspaceID int32 `json:"workspace_id"`
}

// Mark all collections that the user owns as deleted
func (q *Queries) MarkUsersCollectionsAsDeleted(ctx context.Context, arg MarkUsersCollectionsAsDeletedParams) error {
	_, err := q.db.Exec(ctx, markUsersCollectionsAsDeleted, arg.UserID, arg.WorkspaceID)
	return err
}

const reassignCollectionOwnership = `-- name: ReassignCollectionOwnership :exec
with
    target_collections as (
        update collection_members
        set bitmask_role = $4,
        deleted_at = null
        where
            collection_id = any($5::integer[]) and user_id = $1
        returning collection_id
    )
    update collections
    set owner_id = $1
from target_collections
where
    collections.id = target_collections.collection_id
    and collections.owner_id = $2
    and collections.workspace_id = $3
    and collections.deleted_at is null
returning id
`

type ReassignCollectionOwnershipParams struct {
	NewOwnerID    int32     `json:"new_owner_id"`
	OldOwnerID    int32     `json:"old_owner_id"`
	WorkspaceID   int32     `json:"workspace_id"`
	OwnerRole     rbac.Role `json:"owner_role"`
	CollectionIds []int32   `json:"collection_ids"`
}

// Reassign the ownership of a collection to another user
// Also update the collection members to reflect the new owner
func (q *Queries) ReassignCollectionOwnership(ctx context.Context, arg ReassignCollectionOwnershipParams) error {
	_, err := q.db.Exec(ctx, reassignCollectionOwnership,
		arg.NewOwnerID,
		arg.OldOwnerID,
		arg.WorkspaceID,
		arg.OwnerRole,
		arg.CollectionIds,
	)
	return err
}

const removeCollectionMembers = `-- name: RemoveCollectionMembers :many
with
    targets as (
        select cm.id
        from collection_members cm
        join users u on u.id = cm.user_id
        join collections c on c.id = cm.collection_id
        where
            c.id = $1
            and c.workspace_id = $2
            and cm.user_id != c.owner_id
            and (
                $3::bool = true
                or cm.bitmask_role & $4 = 0
            )
            and u.email = any($5::text[])
            and cm.deleted_at is null
            and c.deleted_at is null
    )
    update collection_members
    set deleted_at = now()
where
    id in (select id from targets)
    and collection_members.deleted_at is null
    and collection_members.collection_id = $1
returning id
`

type RemoveCollectionMembersParams struct {
	CollectionID  int32     `json:"collection_id"`
	WorkspaceID   int32     `json:"workspace_id"`
	IncludeAdmins bool      `json:"include_admins"`
	AdminRole     rbac.Role `json:"admin_role"`
	Emails        []string  `json:"emails"`
}

// Remove members from a collection by their email address.
func (q *Queries) RemoveCollectionMembers(ctx context.Context, arg RemoveCollectionMembersParams) ([]int32, error) {
	rows, err := q.db.Query(ctx, removeCollectionMembers,
		arg.CollectionID,
		arg.WorkspaceID,
		arg.IncludeAdmins,
		arg.AdminRole,
		arg.Emails,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int32{}
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCollectionDetails = `-- name: UpdateCollectionDetails :one
update collections
set name = case
        when $1::varchar is not null then $1::varchar
        else name
    end,
    description = case
        when $2::text is not null then $2::text
        else description
    end,
    slug = case
        when $3::text is not null then $3::text
        else slug
    END
where id = $4 and deleted_at is null
returning id, public_id, name, workspace_id, description, avatar_id, created_at, updated_at, deleted_at, slug, owner_id
`

type UpdateCollectionDetailsParams struct {
	Name         pgtype.Text `json:"name"`
	Description  pgtype.Text `json:"description"`
	Slug         pgtype.Text `json:"slug"`
	CollectionID int32       `json:"collection_id"`
}

func (q *Queries) UpdateCollectionDetails(ctx context.Context, arg UpdateCollectionDetailsParams) (Collection, error) {
	row := q.db.QueryRow(ctx, updateCollectionDetails,
		arg.Name,
		arg.Description,
		arg.Slug,
		arg.CollectionID,
	)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.WorkspaceID,
		&i.Description,
		&i.AvatarID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Slug,
		&i.OwnerID,
	)
	return i, err
}
