// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: plugins.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"go.trulyao.dev/hubble/web/pkg/document"
)

const createRemotePluginSource = `-- name: CreateRemotePluginSource :one
INSERT INTO plugin_sources
	(workspace_id, name, description, author, versioning_strategy, git_remote, auth_method, version_id, sync_status)
SELECT workspaces.id, $1, $2, $3, $4, $5, $6, $7, 'idle' FROM workspaces WHERE
	workspaces.id = $8::integer AND workspaces.deleted_at IS NULL
RETURNING id, workspace_id, name, description, author, disabled_at, versioning_strategy, git_remote, auth_method, version_id, sync_status, last_sync_error, last_synced_at, added_at, updated_at, metadata
`

type CreateRemotePluginSourceParams struct {
	Name               string                 `json:"name"`
	Description        pgtype.Text            `json:"description"`
	Author             string                 `json:"author"`
	VersioningStrategy VersioningStrategy     `json:"versioning_strategy"`
	GitRemote          pgtype.Text            `json:"git_remote"`
	AuthMethod         PluginSourceAuthMethod `json:"auth_method"`
	VersionID          pgtype.Text            `json:"version_id"`
	WorkspaceID        int32                  `json:"workspace_id"`
}

func (q *Queries) CreateRemotePluginSource(ctx context.Context, arg CreateRemotePluginSourceParams) (PluginSource, error) {
	row := q.db.QueryRow(ctx, createRemotePluginSource,
		arg.Name,
		arg.Description,
		arg.Author,
		arg.VersioningStrategy,
		arg.GitRemote,
		arg.AuthMethod,
		arg.VersionID,
		arg.WorkspaceID,
	)
	var i PluginSource
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Name,
		&i.Description,
		&i.Author,
		&i.DisabledAt,
		&i.VersioningStrategy,
		&i.GitRemote,
		&i.AuthMethod,
		&i.VersionID,
		&i.SyncStatus,
		&i.LastSyncError,
		&i.LastSyncedAt,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.Metadata,
	)
	return i, err
}

const findInstalledPlugin = `-- name: FindInstalledPlugin :one
select
    i.id, i.plugin_identifier, i.workspace_id, i.source_id, i.name, i.description, i.scope, i.modes, i.entry_types, i.version_sha, i.last_updated_at, i.added_at, i.updated_at, i.metadata, i.tags, i.privileges, s.id as source_id, s.name as source_name, s.git_remote as source_url
from installed_plugins i
join plugin_sources s on s.id = i.source_id
where s.workspace_id = $1 and i.plugin_identifier = $2
`

type FindInstalledPluginParams struct {
	WorkspaceID      pgtype.Int4 `json:"workspace_id"`
	PluginIdentifier string      `json:"plugin_identifier"`
}

type FindInstalledPluginRow struct {
	InstalledPlugin InstalledPlugin `json:"installed_plugin"`
	SourceID        pgtype.UUID     `json:"source_id"`
	SourceName      string          `json:"source_name"`
	SourceUrl       pgtype.Text     `json:"source_url"`
}

func (q *Queries) FindInstalledPlugin(ctx context.Context, arg FindInstalledPluginParams) (FindInstalledPluginRow, error) {
	row := q.db.QueryRow(ctx, findInstalledPlugin, arg.WorkspaceID, arg.PluginIdentifier)
	var i FindInstalledPluginRow
	err := row.Scan(
		&i.InstalledPlugin.ID,
		&i.InstalledPlugin.PluginIdentifier,
		&i.InstalledPlugin.WorkspaceID,
		&i.InstalledPlugin.SourceID,
		&i.InstalledPlugin.Name,
		&i.InstalledPlugin.Description,
		&i.InstalledPlugin.Scope,
		&i.InstalledPlugin.Modes,
		&i.InstalledPlugin.EntryTypes,
		&i.InstalledPlugin.VersionSha,
		&i.InstalledPlugin.LastUpdatedAt,
		&i.InstalledPlugin.AddedAt,
		&i.InstalledPlugin.UpdatedAt,
		&i.InstalledPlugin.Metadata,
		&i.InstalledPlugin.Tags,
		&i.InstalledPlugin.Privileges,
		&i.SourceID,
		&i.SourceName,
		&i.SourceUrl,
	)
	return i, err
}

const findInstalledPluginsByWorkspaceID = `-- name: FindInstalledPluginsByWorkspaceID :many
select
    i.id, i.plugin_identifier, i.workspace_id, i.source_id, i.name, i.description, i.scope, i.modes, i.entry_types, i.version_sha, i.last_updated_at, i.added_at, i.updated_at, i.metadata, i.tags, i.privileges, s.id as source_id, s.name as source_name, s.git_remote as source_url
from installed_plugins i
join plugin_sources s on s.id = i.source_id
where s.workspace_id = $1
`

type FindInstalledPluginsByWorkspaceIDRow struct {
	InstalledPlugin InstalledPlugin `json:"installed_plugin"`
	SourceID        pgtype.UUID     `json:"source_id"`
	SourceName      string          `json:"source_name"`
	SourceUrl       pgtype.Text     `json:"source_url"`
}

func (q *Queries) FindInstalledPluginsByWorkspaceID(ctx context.Context, workspaceID pgtype.Int4) ([]FindInstalledPluginsByWorkspaceIDRow, error) {
	rows, err := q.db.Query(ctx, findInstalledPluginsByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindInstalledPluginsByWorkspaceIDRow{}
	for rows.Next() {
		var i FindInstalledPluginsByWorkspaceIDRow
		if err := rows.Scan(
			&i.InstalledPlugin.ID,
			&i.InstalledPlugin.PluginIdentifier,
			&i.InstalledPlugin.WorkspaceID,
			&i.InstalledPlugin.SourceID,
			&i.InstalledPlugin.Name,
			&i.InstalledPlugin.Description,
			&i.InstalledPlugin.Scope,
			&i.InstalledPlugin.Modes,
			&i.InstalledPlugin.EntryTypes,
			&i.InstalledPlugin.VersionSha,
			&i.InstalledPlugin.LastUpdatedAt,
			&i.InstalledPlugin.AddedAt,
			&i.InstalledPlugin.UpdatedAt,
			&i.InstalledPlugin.Metadata,
			&i.InstalledPlugin.Tags,
			&i.InstalledPlugin.Privileges,
			&i.SourceID,
			&i.SourceName,
			&i.SourceUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findOnCreatePluginsForType = `-- name: FindOnCreatePluginsForType :many
select i.id, i.plugin_identifier, i.workspace_id, i.source_id, i.name, i.description, i.scope, i.modes, i.entry_types, i.version_sha, i.last_updated_at, i.added_at, i.updated_at, i.metadata, i.tags, i.privileges
from installed_plugins i
join entries e on e.id = $1
join workspaces w on w.id = i.workspace_id
where
    'on_create' = any(i.modes)
    and e.entry_type = any(i.entry_types)
    and w.public_id = $2
    and w.deleted_at is null
`

type FindOnCreatePluginsForTypeParams struct {
	EntryID           int32       `json:"entry_id"`
	WorkspacePublicID pgtype.UUID `json:"workspace_public_id"`
}

type FindOnCreatePluginsForTypeRow struct {
	InstalledPlugin InstalledPlugin `json:"installed_plugin"`
}

// This finds all plugins that support the given entry type and have the `on_create`
// mode
func (q *Queries) FindOnCreatePluginsForType(ctx context.Context, arg FindOnCreatePluginsForTypeParams) ([]FindOnCreatePluginsForTypeRow, error) {
	rows, err := q.db.Query(ctx, findOnCreatePluginsForType, arg.EntryID, arg.WorkspacePublicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindOnCreatePluginsForTypeRow{}
	for rows.Next() {
		var i FindOnCreatePluginsForTypeRow
		if err := rows.Scan(
			&i.InstalledPlugin.ID,
			&i.InstalledPlugin.PluginIdentifier,
			&i.InstalledPlugin.WorkspaceID,
			&i.InstalledPlugin.SourceID,
			&i.InstalledPlugin.Name,
			&i.InstalledPlugin.Description,
			&i.InstalledPlugin.Scope,
			&i.InstalledPlugin.Modes,
			&i.InstalledPlugin.EntryTypes,
			&i.InstalledPlugin.VersionSha,
			&i.InstalledPlugin.LastUpdatedAt,
			&i.InstalledPlugin.AddedAt,
			&i.InstalledPlugin.UpdatedAt,
			&i.InstalledPlugin.Metadata,
			&i.InstalledPlugin.Tags,
			&i.InstalledPlugin.Privileges,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPluginSourceByID = `-- name: FindPluginSourceByID :one
select id, workspace_id, name, description, author, disabled_at, versioning_strategy, git_remote, auth_method, version_id, sync_status, last_sync_error, last_synced_at, added_at, updated_at, metadata
from plugin_sources
where workspace_id = $1 and id = $2
`

type FindPluginSourceByIDParams struct {
	WorkspaceID pgtype.Int4 `json:"workspace_id"`
	SourceID    pgtype.UUID `json:"source_id"`
}

func (q *Queries) FindPluginSourceByID(ctx context.Context, arg FindPluginSourceByIDParams) (PluginSource, error) {
	row := q.db.QueryRow(ctx, findPluginSourceByID, arg.WorkspaceID, arg.SourceID)
	var i PluginSource
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Name,
		&i.Description,
		&i.Author,
		&i.DisabledAt,
		&i.VersioningStrategy,
		&i.GitRemote,
		&i.AuthMethod,
		&i.VersionID,
		&i.SyncStatus,
		&i.LastSyncError,
		&i.LastSyncedAt,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.Metadata,
	)
	return i, err
}

const findPluginSourcesByWorkspaceID = `-- name: FindPluginSourcesByWorkspaceID :many
with
    all_sources as (
        select p.id, p.workspace_id, p.name, p.description, p.author, p.disabled_at, p.versioning_strategy, p.git_remote, p.auth_method, p.version_id, p.sync_status, p.last_sync_error, p.last_synced_at, p.added_at, p.updated_at, p.metadata
        from plugin_sources p
        where p.workspace_id = $3 and disabled_at is null
    )
select id, workspace_id, name, description, author, disabled_at, versioning_strategy, git_remote, auth_method, version_id, sync_status, last_sync_error, last_synced_at, added_at, updated_at, metadata, count(*) over () as total_count
from all_sources
order by name asc
limit $1
offset $2
`

type FindPluginSourcesByWorkspaceIDParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	WorkspaceID pgtype.Int4 `json:"workspace_id"`
}

type FindPluginSourcesByWorkspaceIDRow struct {
	ID                 pgtype.UUID            `json:"id"`
	WorkspaceID        pgtype.Int4            `json:"workspace_id"`
	Name               string                 `json:"name"`
	Description        pgtype.Text            `json:"description"`
	Author             string                 `json:"author"`
	DisabledAt         pgtype.Timestamptz     `json:"disabled_at"`
	VersioningStrategy VersioningStrategy     `json:"versioning_strategy"`
	GitRemote          pgtype.Text            `json:"git_remote"`
	AuthMethod         PluginSourceAuthMethod `json:"auth_method"`
	VersionID          pgtype.Text            `json:"version_id"`
	SyncStatus         PluginSyncStatus       `json:"sync_status"`
	LastSyncError      pgtype.Text            `json:"last_sync_error"`
	LastSyncedAt       pgtype.Timestamptz     `json:"last_synced_at"`
	AddedAt            pgtype.Timestamptz     `json:"added_at"`
	UpdatedAt          pgtype.Timestamptz     `json:"updated_at"`
	Metadata           []byte                 `json:"metadata"`
	TotalCount         int64                  `json:"total_count"`
}

func (q *Queries) FindPluginSourcesByWorkspaceID(ctx context.Context, arg FindPluginSourcesByWorkspaceIDParams) ([]FindPluginSourcesByWorkspaceIDRow, error) {
	rows, err := q.db.Query(ctx, findPluginSourcesByWorkspaceID, arg.Limit, arg.Offset, arg.WorkspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindPluginSourcesByWorkspaceIDRow{}
	for rows.Next() {
		var i FindPluginSourcesByWorkspaceIDRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Name,
			&i.Description,
			&i.Author,
			&i.DisabledAt,
			&i.VersioningStrategy,
			&i.GitRemote,
			&i.AuthMethod,
			&i.VersionID,
			&i.SyncStatus,
			&i.LastSyncError,
			&i.LastSyncedAt,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.Metadata,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findSourceByGitRemote = `-- name: FindSourceByGitRemote :one
select id, workspace_id, name, description, author, disabled_at, versioning_strategy, git_remote, auth_method, version_id, sync_status, last_sync_error, last_synced_at, added_at, updated_at, metadata
from plugin_sources
where workspace_id = $1 and git_remote = $2
`

type FindSourceByGitRemoteParams struct {
	WorkspaceID pgtype.Int4 `json:"workspace_id"`
	GitRemote   pgtype.Text `json:"git_remote"`
}

func (q *Queries) FindSourceByGitRemote(ctx context.Context, arg FindSourceByGitRemoteParams) (PluginSource, error) {
	row := q.db.QueryRow(ctx, findSourceByGitRemote, arg.WorkspaceID, arg.GitRemote)
	var i PluginSource
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Name,
		&i.Description,
		&i.Author,
		&i.DisabledAt,
		&i.VersioningStrategy,
		&i.GitRemote,
		&i.AuthMethod,
		&i.VersionID,
		&i.SyncStatus,
		&i.LastSyncError,
		&i.LastSyncedAt,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.Metadata,
	)
	return i, err
}

const pluginKvDelete = `-- name: PluginKvDelete :exec
delete from plugins_kv
where plugin_id = $1 and key = $2
`

type PluginKvDeleteParams struct {
	Identifier string `json:"identifier"`
	Key        string `json:"key"`
}

func (q *Queries) PluginKvDelete(ctx context.Context, arg PluginKvDeleteParams) error {
	_, err := q.db.Exec(ctx, pluginKvDelete, arg.Identifier, arg.Key)
	return err
}

const pluginKvDeleteByPluginID = `-- name: PluginKvDeleteByPluginID :exec
delete from plugins_kv
where plugin_id = $1
`

func (q *Queries) PluginKvDeleteByPluginID(ctx context.Context, identifier string) error {
	_, err := q.db.Exec(ctx, pluginKvDeleteByPluginID, identifier)
	return err
}

const pluginKvGet = `-- name: PluginKvGet :one
select value
from plugins_kv
where key = $1 and plugin_id = $2
`

type PluginKvGetParams struct {
	Key        string `json:"key"`
	Identifier string `json:"identifier"`
}

func (q *Queries) PluginKvGet(ctx context.Context, arg PluginKvGetParams) (string, error) {
	row := q.db.QueryRow(ctx, pluginKvGet, arg.Key, arg.Identifier)
	var value string
	err := row.Scan(&value)
	return value, err
}

const pluginKvGetByPluginID = `-- name: PluginKvGetByPluginID :many
select key, value
from plugins_kv
where plugin_id = $1
`

type PluginKvGetByPluginIDRow struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (q *Queries) PluginKvGetByPluginID(ctx context.Context, identifier string) ([]PluginKvGetByPluginIDRow, error) {
	rows, err := q.db.Query(ctx, pluginKvGetByPluginID, identifier)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PluginKvGetByPluginIDRow{}
	for rows.Next() {
		var i PluginKvGetByPluginIDRow
		if err := rows.Scan(&i.Key, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pluginKvSet = `-- name: PluginKvSet :one
insert into plugins_kv (plugin_id, key, value)
values ($1, $2, $3)
on conflict (plugin_id, key) do update set
	value = excluded.value
returning id, plugin_id, key, value, created_at, updated_at
`

type PluginKvSetParams struct {
	Identifier string `json:"identifier"`
	Key        string `json:"key"`
	Value      string `json:"value"`
}

func (q *Queries) PluginKvSet(ctx context.Context, arg PluginKvSetParams) (PluginsKv, error) {
	row := q.db.QueryRow(ctx, pluginKvSet, arg.Identifier, arg.Key, arg.Value)
	var i PluginsKv
	err := row.Scan(
		&i.ID,
		&i.PluginID,
		&i.Key,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const removeInstalledPlugin = `-- name: RemoveInstalledPlugin :exec
delete from installed_plugins
where workspace_id = $1 and plugin_identifier = $2
`

type RemoveInstalledPluginParams struct {
	WorkspaceID      pgtype.Int4 `json:"workspace_id"`
	PluginIdentifier string      `json:"plugin_identifier"`
}

func (q *Queries) RemoveInstalledPlugin(ctx context.Context, arg RemoveInstalledPluginParams) error {
	_, err := q.db.Exec(ctx, removeInstalledPlugin, arg.WorkspaceID, arg.PluginIdentifier)
	return err
}

const removePluginSource = `-- name: RemovePluginSource :exec
delete from plugin_sources
where
    workspace_id = $1
    and (
        id = $2
        or ($3::text is not null and git_remote = $3)
    )
`

type RemovePluginSourceParams struct {
	WorkspaceID pgtype.Int4 `json:"workspace_id"`
	SourceID    pgtype.UUID `json:"source_id"`
	GitRemote   pgtype.Text `json:"git_remote"`
}

func (q *Queries) RemovePluginSource(ctx context.Context, arg RemovePluginSourceParams) error {
	_, err := q.db.Exec(ctx, removePluginSource, arg.WorkspaceID, arg.SourceID, arg.GitRemote)
	return err
}

const removeSourcePlugins = `-- name: RemoveSourcePlugins :exec
with
    source as (
        select id
        from plugin_sources
        where workspace_id = $1 and git_remote = $2
    )
delete from installed_plugins
where
    installed_plugins.workspace_id = $1
    and source_id in (select id from source)
`

type RemoveSourcePluginsParams struct {
	WorkspaceID pgtype.Int4 `json:"workspace_id"`
	GitRemote   pgtype.Text `json:"git_remote"`
}

func (q *Queries) RemoveSourcePlugins(ctx context.Context, arg RemoveSourcePluginsParams) error {
	_, err := q.db.Exec(ctx, removeSourcePlugins, arg.WorkspaceID, arg.GitRemote)
	return err
}

const sourceExists = `-- name: SourceExists :one
select count(id) > 0
from plugin_sources
where workspace_id = $1 and git_remote = $2
`

type SourceExistsParams struct {
	WorkspaceID pgtype.Int4 `json:"workspace_id"`
	GitRemote   pgtype.Text `json:"git_remote"`
}

func (q *Queries) SourceExists(ctx context.Context, arg SourceExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, sourceExists, arg.WorkspaceID, arg.GitRemote)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const upsertInstalledPlugin = `-- name: UpsertInstalledPlugin :one
insert into installed_plugins (
    plugin_identifier,
    workspace_id,
    source_id,
    name,
    description,
    modes,
    entry_types,
    version_sha,
    last_updated_at,
    privileges,
    added_at
) values(
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    now()
) on conflict (workspace_id, plugin_identifier) do update set
    name = excluded.name,
    description = excluded.description,
    modes = excluded.modes,
    entry_types = excluded.entry_types,
    version_sha = excluded.version_sha,
    privileges = excluded.privileges,
    last_updated_at = excluded.last_updated_at
returning id, plugin_identifier, workspace_id, source_id, name, description, scope, modes, entry_types, version_sha, last_updated_at, added_at, updated_at, metadata, tags, privileges
`

type UpsertInstalledPluginParams struct {
	Identifier          string               `json:"identifier"`
	WorkspaceID         pgtype.Int4          `json:"workspace_id"`
	SourceID            pgtype.UUID          `json:"source_id"`
	Name                string               `json:"name"`
	Description         pgtype.Text          `json:"description"`
	Modes               []PluginMode         `json:"modes"`
	Targets             []document.EntryType `json:"targets"`
	Checksum            string               `json:"checksum"`
	PluginLastUpdatedAt pgtype.Timestamptz   `json:"plugin_last_updated_at"`
	Privileges          []PluginPrivilege    `json:"privileges"`
}

func (q *Queries) UpsertInstalledPlugin(ctx context.Context, arg UpsertInstalledPluginParams) (InstalledPlugin, error) {
	row := q.db.QueryRow(ctx, upsertInstalledPlugin,
		arg.Identifier,
		arg.WorkspaceID,
		arg.SourceID,
		arg.Name,
		arg.Description,
		arg.Modes,
		arg.Targets,
		arg.Checksum,
		arg.PluginLastUpdatedAt,
		arg.Privileges,
	)
	var i InstalledPlugin
	err := row.Scan(
		&i.ID,
		&i.PluginIdentifier,
		&i.WorkspaceID,
		&i.SourceID,
		&i.Name,
		&i.Description,
		&i.Scope,
		&i.Modes,
		&i.EntryTypes,
		&i.VersionSha,
		&i.LastUpdatedAt,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.Metadata,
		&i.Tags,
		&i.Privileges,
	)
	return i, err
}
