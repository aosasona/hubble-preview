// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: workspace.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
	"go.trulyao.dev/hubble/web/pkg/rbac"
)

const collectionExistsInWorkspace = `-- name: CollectionExistsInWorkspace :one
select count(c.id) > 0 as exists
from collections c
left join workspaces w on w.id = c.workspace_id
where w.public_id = $1 and c.public_id = $2
`

type CollectionExistsInWorkspaceParams struct {
	WorkspaceID  pgtype.UUID `json:"workspace_id"`
	CollectionID pgtype.UUID `json:"collection_id"`
}

func (q *Queries) CollectionExistsInWorkspace(ctx context.Context, arg CollectionExistsInWorkspaceParams) (bool, error) {
	row := q.db.QueryRow(ctx, collectionExistsInWorkspace, arg.WorkspaceID, arg.CollectionID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createWorkspace = `-- name: CreateWorkspace :one
insert into workspaces (display_name, owner_id, description, slug)
values ($1, $2, $3, $4)
returning id, public_id, display_name, owner_id, description, avatar_id, enable_public_indexing, invite_only, created_at, updated_at, deleted_at, slug
`

type CreateWorkspaceParams struct {
	Name        string      `json:"name"`
	OwnerID     int32       `json:"owner_id"`
	Description pgtype.Text `json:"description"`
	Slug        pgtype.Text `json:"slug"`
}

func (q *Queries) CreateWorkspace(ctx context.Context, arg CreateWorkspaceParams) (Workspace, error) {
	row := q.db.QueryRow(ctx, createWorkspace,
		arg.Name,
		arg.OwnerID,
		arg.Description,
		arg.Slug,
	)
	var i Workspace
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.DisplayName,
		&i.OwnerID,
		&i.Description,
		&i.AvatarID,
		&i.EnablePublicIndexing,
		&i.InviteOnly,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Slug,
	)
	return i, err
}

const createWorkspaceMember = `-- name: CreateWorkspaceMember :one
insert into workspace_members(workspace_id, user_id, bitmask_role)
values($1, $2, $3)
on conflict (workspace_id, user_id) do update set
    bitmask_role = EXCLUDED.bitmask_role,
    deleted_at = null
returning id, workspace_id, user_id, bitmask_role, extra_permissions, created_at, updated_at, deleted_at
`

type CreateWorkspaceMemberParams struct {
	WorkspaceID int32     `json:"workspace_id"`
	UserID      int32     `json:"user_id"`
	Role        rbac.Role `json:"role"`
}

// Create a workspace member. If the user already exists in the workspace and was
// deleted, restore them.
func (q *Queries) CreateWorkspaceMember(ctx context.Context, arg CreateWorkspaceMemberParams) (WorkspaceMember, error) {
	row := q.db.QueryRow(ctx, createWorkspaceMember, arg.WorkspaceID, arg.UserID, arg.Role)
	var i WorkspaceMember
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.UserID,
		&i.BitmaskRole,
		&i.ExtraPermissions,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const findAllWorkspacesByUserID = `-- name: FindAllWorkspacesByUserID :many
select w.id, w.public_id, w.display_name, w.owner_id, w.description, w.avatar_id, w.enable_public_indexing, w.invite_only, w.created_at, w.updated_at, w.deleted_at, w.slug
from workspaces w
inner join workspace_members wm on wm.workspace_id = w.id
where wm.user_id = $1 and w.deleted_at is null and wm.deleted_at is null
order by w.display_name asc, w.created_at desc
`

func (q *Queries) FindAllWorkspacesByUserID(ctx context.Context, userID int32) ([]Workspace, error) {
	rows, err := q.db.Query(ctx, findAllWorkspacesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Workspace{}
	for rows.Next() {
		var i Workspace
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.DisplayName,
			&i.OwnerID,
			&i.Description,
			&i.AvatarID,
			&i.EnablePublicIndexing,
			&i.InviteOnly,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Slug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findInviteById = `-- name: FindInviteById :one
select
    i.id,
    i.invite_id,
    w.id as workspace_id,
    w.public_id as workspace_public_id,
    w.display_name as workspace_name,
    w.slug as workspace_slug,
    inviter.id, inviter.public_id, inviter.first_name, inviter.last_name, inviter.email, inviter.username, inviter.hashed_password, inviter.email_verified, inviter.created_at, inviter.updated_at, inviter.deleted_at, inviter.avatar_id,
    i.role,
    -- fmt: off
    case
        when i.accepted_at is not null then 'accepted'
        when i.declined_at is not null then 'declined'
        when i.deleted_at is not null then 'revoked'
        when i.invited_at + interval '14 days' < now() then 'expired'
        else 'pending'
    end as status,
    i.email as invited_email,
    i.invited_at,
    u.id as invited_user_id,
    (u.id is not null)::bool as invited_user_exists
from workspace_invites i
join workspaces w on w.id = i.workspace_id
join users inviter on inviter.id = i.invited_by
left join users u on u.email = i.email
where i.invite_id = $1 and inviter.deleted_at is null and w.deleted_at is null
`

type FindInviteByIdRow struct {
	ID                int32              `json:"id"`
	InviteID          pgtype.UUID        `json:"invite_id"`
	WorkspaceID       int32              `json:"workspace_id"`
	WorkspacePublicID pgtype.UUID        `json:"workspace_public_id"`
	WorkspaceName     string             `json:"workspace_name"`
	WorkspaceSlug     pgtype.Text        `json:"workspace_slug"`
	User              User               `json:"user"`
	Role              rbac.Role          `json:"role"`
	Status            string             `json:"status"`
	InvitedEmail      string             `json:"invited_email"`
	InvitedAt         pgtype.Timestamptz `json:"invited_at"`
	InvitedUserID     pgtype.Int4        `json:"invited_user_id"`
	InvitedUserExists bool               `json:"invited_user_exists"`
}

func (q *Queries) FindInviteById(ctx context.Context, inviteID pgtype.UUID) (FindInviteByIdRow, error) {
	row := q.db.QueryRow(ctx, findInviteById, inviteID)
	var i FindInviteByIdRow
	err := row.Scan(
		&i.ID,
		&i.InviteID,
		&i.WorkspaceID,
		&i.WorkspacePublicID,
		&i.WorkspaceName,
		&i.WorkspaceSlug,
		&i.User.ID,
		&i.User.PublicID,
		&i.User.FirstName,
		&i.User.LastName,
		&i.User.Email,
		&i.User.Username,
		&i.User.HashedPassword,
		&i.User.EmailVerified,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.DeletedAt,
		&i.User.AvatarID,
		&i.Role,
		&i.Status,
		&i.InvitedEmail,
		&i.InvitedAt,
		&i.InvitedUserID,
		&i.InvitedUserExists,
	)
	return i, err
}

const findWorkspaceByID = `-- name: FindWorkspaceByID :one
select w.id, w.public_id, w.display_name, w.owner_id, w.description, w.avatar_id, w.enable_public_indexing, w.invite_only, w.created_at, w.updated_at, w.deleted_at, w.slug
from workspaces w
where id = $1 and deleted_at is null
`

type FindWorkspaceByIDRow struct {
	Workspace Workspace `json:"workspace"`
}

func (q *Queries) FindWorkspaceByID(ctx context.Context, id int32) (FindWorkspaceByIDRow, error) {
	row := q.db.QueryRow(ctx, findWorkspaceByID, id)
	var i FindWorkspaceByIDRow
	err := row.Scan(
		&i.Workspace.ID,
		&i.Workspace.PublicID,
		&i.Workspace.DisplayName,
		&i.Workspace.OwnerID,
		&i.Workspace.Description,
		&i.Workspace.AvatarID,
		&i.Workspace.EnablePublicIndexing,
		&i.Workspace.InviteOnly,
		&i.Workspace.CreatedAt,
		&i.Workspace.UpdatedAt,
		&i.Workspace.DeletedAt,
		&i.Workspace.Slug,
	)
	return i, err
}

const findWorkspaceByPublicID = `-- name: FindWorkspaceByPublicID :one
select id, public_id, display_name, owner_id, description, avatar_id, enable_public_indexing, invite_only, created_at, updated_at, deleted_at, slug
from workspaces
where public_id = $1 and deleted_at is null
`

func (q *Queries) FindWorkspaceByPublicID(ctx context.Context, publicID pgtype.UUID) (Workspace, error) {
	row := q.db.QueryRow(ctx, findWorkspaceByPublicID, publicID)
	var i Workspace
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.DisplayName,
		&i.OwnerID,
		&i.Description,
		&i.AvatarID,
		&i.EnablePublicIndexing,
		&i.InviteOnly,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Slug,
	)
	return i, err
}

const findWorkspaceIdBySlug = `-- name: FindWorkspaceIdBySlug :one
select public_id
from workspaces
where slug = $1 and deleted_at is null
`

func (q *Queries) FindWorkspaceIdBySlug(ctx context.Context, slug pgtype.Text) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, findWorkspaceIdBySlug, slug)
	var public_id pgtype.UUID
	err := row.Scan(&public_id)
	return public_id, err
}

const findWorkspaceMembers = `-- name: FindWorkspaceMembers :many
with
    members_and_invites as (
        select
            wm.id,
            u.id as user_id,
            u.public_id as public_user_id,
            u.first_name,
            u.last_name,
            u.email,
            wm.bitmask_role as role,
            wm.created_at,
            'accepted' as status,
            '' as invite_id
        from workspace_members wm
        left join users u on u.id = wm.user_id
        left join workspaces w on w.id = wm.workspace_id
        where w.public_id = $3 and wm.deleted_at is null
        union all
        select
            i.id,
            coalesce(u.id, null) as user_id,
            coalesce(u.public_id, null) as public_user_id,
            coalesce(u.first_name, null) as first_name,
            coalesce(u.last_name, null) as last_name,
            i.email,
            i.role,
            i.invited_at,
            -- fmt: off
            case
                when i.declined_at is not null then 'declined'
                when i.deleted_at is not null then 'revoked'
                when i.invited_at + interval '14 days' < now() then 'expired'
                else 'pending'
            end as status,
            i.invite_id::text as invite_id
        from workspace_invites i
        left join workspaces w on w.id = i.workspace_id
        left join users u on u.email = i.email
        where
            w.public_id = $3
            and i.accepted_at is null
            and i.deleted_at is null
    )
select id, user_id, public_user_id, first_name, last_name, email, role, created_at, status, invite_id, count(*) over () as total_count
from members_and_invites
limit $1
offset $2
`

type FindWorkspaceMembersParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	WorkspaceID pgtype.UUID `json:"workspace_id"`
}

type FindWorkspaceMembersRow struct {
	ID           int32              `json:"id"`
	UserID       pgtype.Int4        `json:"user_id"`
	PublicUserID pgtype.UUID        `json:"public_user_id"`
	FirstName    pgtype.Text        `json:"first_name"`
	LastName     pgtype.Text        `json:"last_name"`
	Email        pgtype.Text        `json:"email"`
	Role         int32              `json:"role"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	Status       string             `json:"status"`
	InviteID     string             `json:"invite_id"`
	TotalCount   int64              `json:"total_count"`
}

func (q *Queries) FindWorkspaceMembers(ctx context.Context, arg FindWorkspaceMembersParams) ([]FindWorkspaceMembersRow, error) {
	rows, err := q.db.Query(ctx, findWorkspaceMembers, arg.Limit, arg.Offset, arg.WorkspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindWorkspaceMembersRow{}
	for rows.Next() {
		var i FindWorkspaceMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PublicUserID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Role,
			&i.CreatedAt,
			&i.Status,
			&i.InviteID,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findWorkspaceMemeber = `-- name: FindWorkspaceMemeber :one
select
    wm.id,
    u.id as user_id,
    u.public_id as public_user_id,
    u.first_name,
    u.last_name,
    u.email,
    wm.bitmask_role as role,
    wm.created_at,
    -- fmt: off
    case
        when i.accepted_at is not null then 'accepted'
        when i.declined_at is not null then 'declined'
        when i.deleted_at is not null then 'revoked'
        when i.invited_at + interval '14 days' < now() then 'expired'
        else 'pending'
    end as status,
    i.invite_id as invite_id
from workspace_members wm
join users u on u.id = wm.user_id
join workspaces w on w.id = wm.workspace_id
left join workspace_invites i on i.email = u.email and i.workspace_id = w.id
where w.public_id = $1
    and ($2::integer is null or wm.user_id = $2::integer)
    and ($3::text is null or u.email = $3::text)
    and ($4::integer is null or wm.id = $4::integer)
    and wm.deleted_at is null
	and w.deleted_at is null
	and u.deleted_at is null
`

type FindWorkspaceMemeberParams struct {
	WorkspaceID pgtype.UUID `json:"workspace_id"`
	UserID      pgtype.Int4 `json:"user_id"`
	Email       pgtype.Text `json:"email"`
	MemberID    pgtype.Int4 `json:"member_id"`
}

type FindWorkspaceMemeberRow struct {
	ID           int32              `json:"id"`
	UserID       int32              `json:"user_id"`
	PublicUserID pgtype.UUID        `json:"public_user_id"`
	FirstName    string             `json:"first_name"`
	LastName     string             `json:"last_name"`
	Email        string             `json:"email"`
	Role         rbac.Role          `json:"role"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	Status       string             `json:"status"`
	InviteID     pgtype.UUID        `json:"invite_id"`
}

func (q *Queries) FindWorkspaceMemeber(ctx context.Context, arg FindWorkspaceMemeberParams) (FindWorkspaceMemeberRow, error) {
	row := q.db.QueryRow(ctx, findWorkspaceMemeber,
		arg.WorkspaceID,
		arg.UserID,
		arg.Email,
		arg.MemberID,
	)
	var i FindWorkspaceMemeberRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PublicUserID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Role,
		&i.CreatedAt,
		&i.Status,
		&i.InviteID,
	)
	return i, err
}

const findWorkspaceWithMembershipStatus = `-- name: FindWorkspaceWithMembershipStatus :one
select
    w.id, w.public_id, w.display_name, w.owner_id, w.description, w.avatar_id, w.enable_public_indexing, w.invite_only, w.created_at, w.updated_at, w.deleted_at, w.slug,
    (wm.id is not null and wm.deleted_at is null)::bool as is_member,
    case
        when (wm.id is not null and wm.deleted_at is null) then wm.bitmask_role else 0
    end as role,
    wm.id as member_id,
    wm.user_id as member_user_id
from workspaces w
left join workspace_members wm on wm.workspace_id = w.id and wm.user_id = $1
where (w.public_id = $2 or w.slug = $3) and w.deleted_at is null
`

type FindWorkspaceWithMembershipStatusParams struct {
	UserID   int32       `json:"user_id"`
	PublicID pgtype.UUID `json:"public_id"`
	Slug     pgtype.Text `json:"slug"`
}

type FindWorkspaceWithMembershipStatusRow struct {
	ID                   int32              `json:"id"`
	PublicID             pgtype.UUID        `json:"public_id"`
	DisplayName          string             `json:"display_name"`
	OwnerID              int32              `json:"owner_id"`
	Description          pgtype.Text        `json:"description"`
	AvatarID             pgtype.Text        `json:"avatar_id"`
	EnablePublicIndexing bool               `json:"enable_public_indexing"`
	InviteOnly           bool               `json:"invite_only"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	DeletedAt            pgtype.Timestamptz `json:"deleted_at"`
	Slug                 pgtype.Text        `json:"slug"`
	IsMember             bool               `json:"is_member"`
	Role                 int32              `json:"role"`
	MemberID             pgtype.Int4        `json:"member_id"`
	MemberUserID         pgtype.Int4        `json:"member_user_id"`
}

// Find a workspace by its public_id or slug and check if the user has permissions to
// access it
func (q *Queries) FindWorkspaceWithMembershipStatus(ctx context.Context, arg FindWorkspaceWithMembershipStatusParams) (FindWorkspaceWithMembershipStatusRow, error) {
	row := q.db.QueryRow(ctx, findWorkspaceWithMembershipStatus, arg.UserID, arg.PublicID, arg.Slug)
	var i FindWorkspaceWithMembershipStatusRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.DisplayName,
		&i.OwnerID,
		&i.Description,
		&i.AvatarID,
		&i.EnablePublicIndexing,
		&i.InviteOnly,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Slug,
		&i.IsMember,
		&i.Role,
		&i.MemberID,
		&i.MemberUserID,
	)
	return i, err
}

const getUserMembership = `-- name: GetUserMembership :one
select id, workspace_id, user_id, bitmask_role, extra_permissions, created_at, updated_at, deleted_at
from workspace_members
where workspace_id = $1 and user_id = $2 and deleted_at is null
`

type GetUserMembershipParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	UserID      int32 `json:"user_id"`
}

func (q *Queries) GetUserMembership(ctx context.Context, arg GetUserMembershipParams) (WorkspaceMember, error) {
	row := q.db.QueryRow(ctx, getUserMembership, arg.WorkspaceID, arg.UserID)
	var i WorkspaceMember
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.UserID,
		&i.BitmaskRole,
		&i.ExtraPermissions,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const markWorkspaceAsDeleted = `-- name: MarkWorkspaceAsDeleted :execresult
update workspaces
set deleted_at = now()
where public_id = $1 and deleted_at is null
`

// Mark a workspace as deleted, and all its entries, collections, and members as deleted.
func (q *Queries) MarkWorkspaceAsDeleted(ctx context.Context, workspaceID pgtype.UUID) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, markWorkspaceAsDeleted, workspaceID)
}

const markWorkspaceMemberAsDeleted = `-- name: MarkWorkspaceMemberAsDeleted :execresult
update workspace_members
set deleted_at = now()
where workspace_id = $1 and user_id = $2
`

type MarkWorkspaceMemberAsDeletedParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	UserID      int32 `json:"user_id"`
}

// Mark a workspace member as deleted. This is used when a user leaves a workspace
// or is removed from it.
func (q *Queries) MarkWorkspaceMemberAsDeleted(ctx context.Context, arg MarkWorkspaceMemberAsDeletedParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, markWorkspaceMemberAsDeleted, arg.WorkspaceID, arg.UserID)
}

const updateAllCollectionMemberRole = `-- name: UpdateAllCollectionMemberRole :exec
update collection_members
set bitmask_role = $1
from users
where
    collection_members.user_id = users.id
    and users.public_id = $2
    and (collection_members.bitmask_role & $3) = 0
`

type UpdateAllCollectionMemberRoleParams struct {
	Role      rbac.Role   `json:"role"`
	UserID    pgtype.UUID `json:"user_id"`
	OwnerRole rbac.Role   `json:"owner_role"`
}

// Update all collection members roles where the user is a member but not an owner
func (q *Queries) UpdateAllCollectionMemberRole(ctx context.Context, arg UpdateAllCollectionMemberRoleParams) error {
	_, err := q.db.Exec(ctx, updateAllCollectionMemberRole, arg.Role, arg.UserID, arg.OwnerRole)
	return err
}

const updateWorkspaceDetails = `-- name: UpdateWorkspaceDetails :one
update workspaces
set display_name = case
        when $1::varchar is not null then $1::varchar
        else display_name
    end,
    description = case
        when $2::text is not null then $2::text
        else description
    end,
    slug = case
        when $3::text is not null then $3::text
        else slug
    end
where id = $4 and deleted_at is null
returning id, public_id, display_name, owner_id, description, avatar_id, enable_public_indexing, invite_only, created_at, updated_at, deleted_at, slug
`

type UpdateWorkspaceDetailsParams struct {
	Name        pgtype.Text `json:"name"`
	Description pgtype.Text `json:"description"`
	Slug        pgtype.Text `json:"slug"`
	WorkspaceID int32       `json:"workspace_id"`
}

func (q *Queries) UpdateWorkspaceDetails(ctx context.Context, arg UpdateWorkspaceDetailsParams) (Workspace, error) {
	row := q.db.QueryRow(ctx, updateWorkspaceDetails,
		arg.Name,
		arg.Description,
		arg.Slug,
		arg.WorkspaceID,
	)
	var i Workspace
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.DisplayName,
		&i.OwnerID,
		&i.Description,
		&i.AvatarID,
		&i.EnablePublicIndexing,
		&i.InviteOnly,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Slug,
	)
	return i, err
}

const updateWorkspaceInviteStatus = `-- name: UpdateWorkspaceInviteStatus :one
update workspace_invites
set accepted_at = case when $1::text = 'accepted' then now() else null end,
	declined_at = case when $1::text = 'declined' then now() else null end,
	deleted_at = case when $1::text = 'revoked' then now() else null end
where invite_id = $2
returning id, invite_id, workspace_id, invited_by, invited_at, accepted_at, declined_at, deleted_at, email, role, updated_at
`

type UpdateWorkspaceInviteStatusParams struct {
	Status   string      `json:"status"`
	InviteID pgtype.UUID `json:"invite_id"`
}

func (q *Queries) UpdateWorkspaceInviteStatus(ctx context.Context, arg UpdateWorkspaceInviteStatusParams) (WorkspaceInvite, error) {
	row := q.db.QueryRow(ctx, updateWorkspaceInviteStatus, arg.Status, arg.InviteID)
	var i WorkspaceInvite
	err := row.Scan(
		&i.ID,
		&i.InviteID,
		&i.WorkspaceID,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.AcceptedAt,
		&i.DeclinedAt,
		&i.DeletedAt,
		&i.Email,
		&i.Role,
		&i.UpdatedAt,
	)
	return i, err
}

const updateWorkspaceMemberRole = `-- name: UpdateWorkspaceMemberRole :exec
update workspace_members
set bitmask_role = $1
from users
where workspace_members.user_id = users.id
    and workspace_members.workspace_id = $2
    and users.public_id = $3
	and workspace_members.deleted_at is null
	and users.deleted_at is null
`

type UpdateWorkspaceMemberRoleParams struct {
	Role        rbac.Role   `json:"role"`
	WorkspaceID int32       `json:"workspace_id"`
	UserID      pgtype.UUID `json:"user_id"`
}

func (q *Queries) UpdateWorkspaceMemberRole(ctx context.Context, arg UpdateWorkspaceMemberRoleParams) error {
	_, err := q.db.Exec(ctx, updateWorkspaceMemberRole, arg.Role, arg.WorkspaceID, arg.UserID)
	return err
}

const upsertWorkspaceInvite = `-- name: UpsertWorkspaceInvite :one
insert into workspace_invites (workspace_id, email, role, invited_by)
values ($1, $2, $3, $4)
on conflict (workspace_id, email) do update set
	invite_id = gen_random_uuid(),
    role = EXCLUDED.role,
	invited_by = EXCLUDED.invited_by,
    invited_at = now(),
    accepted_at = null,
    declined_at = null,
    deleted_at = null
returning id, invite_id, workspace_id, invited_by, invited_at, accepted_at, declined_at, deleted_at, email, role, updated_at
`

type UpsertWorkspaceInviteParams struct {
	WorkspaceID int32     `json:"workspace_id"`
	Email       string    `json:"email"`
	Role        rbac.Role `json:"role"`
	InvitedBy   int32     `json:"invited_by"`
}

// reset the invite if it already exists
func (q *Queries) UpsertWorkspaceInvite(ctx context.Context, arg UpsertWorkspaceInviteParams) (WorkspaceInvite, error) {
	row := q.db.QueryRow(ctx, upsertWorkspaceInvite,
		arg.WorkspaceID,
		arg.Email,
		arg.Role,
		arg.InvitedBy,
	)
	var i WorkspaceInvite
	err := row.Scan(
		&i.ID,
		&i.InviteID,
		&i.WorkspaceID,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.AcceptedAt,
		&i.DeclinedAt,
		&i.DeletedAt,
		&i.Email,
		&i.Role,
		&i.UpdatedAt,
	)
	return i, err
}

const workspaceMemberExists = `-- name: WorkspaceMemberExists :one
select (count(wm.id) > 0) as exists
from workspace_members wm
join users u on u.id = wm.user_id
where
    wm.workspace_id = $1
    and ($2::text is null or u.email = $2::text)
    and ($3::integer is null or u.id = $3::integer)
    and (
        $4::uuid is null
        or u.public_id = $4::uuid
    )
    and wm.deleted_at is null
`

type WorkspaceMemberExistsParams struct {
	WorkspaceID  int32       `json:"workspace_id"`
	Email        pgtype.Text `json:"email"`
	UserID       pgtype.Int4 `json:"user_id"`
	PublicUserID pgtype.UUID `json:"public_user_id"`
}

func (q *Queries) WorkspaceMemberExists(ctx context.Context, arg WorkspaceMemberExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, workspaceMemberExists,
		arg.WorkspaceID,
		arg.Email,
		arg.UserID,
		arg.PublicUserID,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const workspaceNameExists = `-- name: WorkspaceNameExists :one
select count(id) > 0 as exists
from workspaces
where
    lower(display_name) = lower($1)
    and owner_id = $2
    and deleted_at is null
`

type WorkspaceNameExistsParams struct {
	DisplayName string `json:"display_name"`
	OwnerID     int32  `json:"owner_id"`
}

func (q *Queries) WorkspaceNameExists(ctx context.Context, arg WorkspaceNameExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, workspaceNameExists, arg.DisplayName, arg.OwnerID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const workspaceSlugExists = `-- name: WorkspaceSlugExists :one
select count(id) > 0 as exists
from workspaces
where slug = $1
`

func (q *Queries) WorkspaceSlugExists(ctx context.Context, slug pgtype.Text) (bool, error) {
	row := q.db.QueryRow(ctx, workspaceSlugExists, slug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
