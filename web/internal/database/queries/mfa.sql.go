// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: mfa.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const activateMfaAccount = `-- name: ActivateMfaAccount :exec
update mfa_accounts m
set active = true, preferred = (select count(*) = 0 from mfa_accounts ml where ml.user_id = $1 and ml.active = true)
where m.id = $2 and m.user_id = $1
`

type ActivateMfaAccountParams struct {
	UserID int32       `json:"user_id"`
	ID     pgtype.UUID `json:"id"`
}

// Activate the MFA account and set it as preferred if it is the only one (i.e. none
// are active)
func (q *Queries) ActivateMfaAccount(ctx context.Context, arg ActivateMfaAccountParams) error {
	_, err := q.db.Exec(ctx, activateMfaAccount, arg.UserID, arg.ID)
	return err
}

const canGenerateBackupCodes = `-- name: CanGenerateBackupCodes :one
select count(id) = 0 as can_generate
from mfa_backup_tokens
where user_id = $1 and created_at > now() - interval '7 days'
`

// Check if the backup codes were generated less then 7 days ago
func (q *Queries) CanGenerateBackupCodes(ctx context.Context, userID int32) (bool, error) {
	row := q.db.QueryRow(ctx, canGenerateBackupCodes, userID)
	var can_generate bool
	err := row.Scan(&can_generate)
	return can_generate, err
}

const createEmailMfaAccount = `-- name: CreateEmailMfaAccount :one
insert into mfa_accounts (user_id, account_type, meta, active, preferred)
values ($1, 'email', $2, false, false)
returning id, user_id, account_type, meta, active, created_at, updated_at, last_used_at, preferred
`

type CreateEmailMfaAccountParams struct {
	UserID int32  `json:"user_id"`
	Meta   []byte `json:"meta"`
}

func (q *Queries) CreateEmailMfaAccount(ctx context.Context, arg CreateEmailMfaAccountParams) (MfaAccount, error) {
	row := q.db.QueryRow(ctx, createEmailMfaAccount, arg.UserID, arg.Meta)
	var i MfaAccount
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountType,
		&i.Meta,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
		&i.Preferred,
	)
	return i, err
}

const createTotpMfaAccount = `-- name: CreateTotpMfaAccount :one
insert into mfa_accounts (user_id, account_type, meta, active, preferred)
values ($1, 'totp', $2, true, false)
returning id, user_id, account_type, meta, active, created_at, updated_at, last_used_at, preferred
`

type CreateTotpMfaAccountParams struct {
	UserID int32  `json:"user_id"`
	Meta   []byte `json:"meta"`
}

func (q *Queries) CreateTotpMfaAccount(ctx context.Context, arg CreateTotpMfaAccountParams) (MfaAccount, error) {
	row := q.db.QueryRow(ctx, createTotpMfaAccount, arg.UserID, arg.Meta)
	var i MfaAccount
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountType,
		&i.Meta,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
		&i.Preferred,
	)
	return i, err
}

const deleteAllBackupCodes = `-- name: DeleteAllBackupCodes :exec
delete from mfa_backup_tokens
where user_id = $1
`

func (q *Queries) DeleteAllBackupCodes(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteAllBackupCodes, userID)
	return err
}

const deleteMfaAccount = `-- name: DeleteMfaAccount :exec
delete from mfa_accounts
where id = $1 and user_id = $2
`

type DeleteMfaAccountParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID int32       `json:"user_id"`
}

func (q *Queries) DeleteMfaAccount(ctx context.Context, arg DeleteMfaAccountParams) error {
	_, err := q.db.Exec(ctx, deleteMfaAccount, arg.ID, arg.UserID)
	return err
}

const findActiveMfaAccountIdsByUserId = `-- name: FindActiveMfaAccountIdsByUserId :many
select id
from mfa_accounts
where user_id = $1 and active = true
order by created_at desc
`

func (q *Queries) FindActiveMfaAccountIdsByUserId(ctx context.Context, userID int32) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, findActiveMfaAccountIdsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.UUID{}
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findActiveMfaAccountsByUserId = `-- name: FindActiveMfaAccountsByUserId :many
select id, account_type, active, meta, user_id, created_at, last_used_at, preferred
from mfa_accounts
where user_id = $1 and active = true
order by created_at asc
`

type FindActiveMfaAccountsByUserIdRow struct {
	ID          pgtype.UUID        `json:"id"`
	AccountType MfaAccountType     `json:"account_type"`
	Active      bool               `json:"active"`
	Meta        []byte             `json:"meta"`
	UserID      int32              `json:"user_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	LastUsedAt  pgtype.Timestamptz `json:"last_used_at"`
	Preferred   bool               `json:"preferred"`
}

func (q *Queries) FindActiveMfaAccountsByUserId(ctx context.Context, userID int32) ([]FindActiveMfaAccountsByUserIdRow, error) {
	rows, err := q.db.Query(ctx, findActiveMfaAccountsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindActiveMfaAccountsByUserIdRow{}
	for rows.Next() {
		var i FindActiveMfaAccountsByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountType,
			&i.Active,
			&i.Meta,
			&i.UserID,
			&i.CreatedAt,
			&i.LastUsedAt,
			&i.Preferred,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllMfaAccountsByUserId = `-- name: FindAllMfaAccountsByUserId :many
select id, account_type, active, meta, created_at, last_used_at, preferred
from mfa_accounts
where user_id = $1
order by created_at asc
`

type FindAllMfaAccountsByUserIdRow struct {
	ID          pgtype.UUID        `json:"id"`
	AccountType MfaAccountType     `json:"account_type"`
	Active      bool               `json:"active"`
	Meta        []byte             `json:"meta"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	LastUsedAt  pgtype.Timestamptz `json:"last_used_at"`
	Preferred   bool               `json:"preferred"`
}

func (q *Queries) FindAllMfaAccountsByUserId(ctx context.Context, userID int32) ([]FindAllMfaAccountsByUserIdRow, error) {
	rows, err := q.db.Query(ctx, findAllMfaAccountsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindAllMfaAccountsByUserIdRow{}
	for rows.Next() {
		var i FindAllMfaAccountsByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountType,
			&i.Active,
			&i.Meta,
			&i.CreatedAt,
			&i.LastUsedAt,
			&i.Preferred,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findBackupCodesByUserId = `-- name: FindBackupCodesByUserId :many
select id, hashed_token, used_at
from mfa_backup_tokens
where user_id = $1
`

type FindBackupCodesByUserIdRow struct {
	ID          int32              `json:"id"`
	HashedToken string             `json:"hashed_token"`
	UsedAt      pgtype.Timestamptz `json:"used_at"`
}

func (q *Queries) FindBackupCodesByUserId(ctx context.Context, userID int32) ([]FindBackupCodesByUserIdRow, error) {
	rows, err := q.db.Query(ctx, findBackupCodesByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindBackupCodesByUserIdRow{}
	for rows.Next() {
		var i FindBackupCodesByUserIdRow
		if err := rows.Scan(&i.ID, &i.HashedToken, &i.UsedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findMfaAccountByEmail = `-- name: FindMfaAccountByEmail :one
select id, account_type, active, meta, user_id, created_at, last_used_at, preferred
from mfa_accounts
where account_type = 'email' and (meta ->> 'email')::text = $1::text
`

type FindMfaAccountByEmailRow struct {
	ID          pgtype.UUID        `json:"id"`
	AccountType MfaAccountType     `json:"account_type"`
	Active      bool               `json:"active"`
	Meta        []byte             `json:"meta"`
	UserID      int32              `json:"user_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	LastUsedAt  pgtype.Timestamptz `json:"last_used_at"`
	Preferred   bool               `json:"preferred"`
}

func (q *Queries) FindMfaAccountByEmail(ctx context.Context, email string) (FindMfaAccountByEmailRow, error) {
	row := q.db.QueryRow(ctx, findMfaAccountByEmail, email)
	var i FindMfaAccountByEmailRow
	err := row.Scan(
		&i.ID,
		&i.AccountType,
		&i.Active,
		&i.Meta,
		&i.UserID,
		&i.CreatedAt,
		&i.LastUsedAt,
		&i.Preferred,
	)
	return i, err
}

const findMfaAccountById = `-- name: FindMfaAccountById :one
select id, account_type, active, meta, user_id, created_at, last_used_at, preferred
from mfa_accounts
where id = $1
`

type FindMfaAccountByIdRow struct {
	ID          pgtype.UUID        `json:"id"`
	AccountType MfaAccountType     `json:"account_type"`
	Active      bool               `json:"active"`
	Meta        []byte             `json:"meta"`
	UserID      int32              `json:"user_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	LastUsedAt  pgtype.Timestamptz `json:"last_used_at"`
	Preferred   bool               `json:"preferred"`
}

func (q *Queries) FindMfaAccountById(ctx context.Context, id pgtype.UUID) (FindMfaAccountByIdRow, error) {
	row := q.db.QueryRow(ctx, findMfaAccountById, id)
	var i FindMfaAccountByIdRow
	err := row.Scan(
		&i.ID,
		&i.AccountType,
		&i.Active,
		&i.Meta,
		&i.UserID,
		&i.CreatedAt,
		&i.LastUsedAt,
		&i.Preferred,
	)
	return i, err
}

const findPreferredMfaAccountByUserId = `-- name: FindPreferredMfaAccountByUserId :one
select id, account_type, active, meta, user_id, created_at, last_used_at, preferred
from mfa_accounts
where user_id = $1 and active = true
order by preferred desc, created_at desc
limit 1
`

type FindPreferredMfaAccountByUserIdRow struct {
	ID          pgtype.UUID        `json:"id"`
	AccountType MfaAccountType     `json:"account_type"`
	Active      bool               `json:"active"`
	Meta        []byte             `json:"meta"`
	UserID      int32              `json:"user_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	LastUsedAt  pgtype.Timestamptz `json:"last_used_at"`
	Preferred   bool               `json:"preferred"`
}

// Find the one marked as preferred, if any, or the first one created and active if
// none are marked as preferred
func (q *Queries) FindPreferredMfaAccountByUserId(ctx context.Context, userID int32) (FindPreferredMfaAccountByUserIdRow, error) {
	row := q.db.QueryRow(ctx, findPreferredMfaAccountByUserId, userID)
	var i FindPreferredMfaAccountByUserIdRow
	err := row.Scan(
		&i.ID,
		&i.AccountType,
		&i.Active,
		&i.Meta,
		&i.UserID,
		&i.CreatedAt,
		&i.LastUsedAt,
		&i.Preferred,
	)
	return i, err
}

const markBackupCodeAsUsed = `-- name: MarkBackupCodeAsUsed :exec
update mfa_backup_tokens
set used_at = now()
where user_id = $1 and id = $2
`

type MarkBackupCodeAsUsedParams struct {
	UserID int32 `json:"user_id"`
	CodeID int32 `json:"code_id"`
}

func (q *Queries) MarkBackupCodeAsUsed(ctx context.Context, arg MarkBackupCodeAsUsedParams) error {
	_, err := q.db.Exec(ctx, markBackupCodeAsUsed, arg.UserID, arg.CodeID)
	return err
}

const mfaAccountNameExists = `-- name: MfaAccountNameExists :one
select count(id) > 0 as exists
from mfa_accounts
where lower(meta ->> 'name')::text = lower($1::text) and user_id = $2
`

type MfaAccountNameExistsParams struct {
	Name   string `json:"name"`
	UserID int32  `json:"user_id"`
}

func (q *Queries) MfaAccountNameExists(ctx context.Context, arg MfaAccountNameExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, mfaAccountNameExists, arg.Name, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const mfaEnabled = `-- name: MfaEnabled :one
select (count(m.id) > 0) as enabled
from mfa_accounts as m
where m.user_id = $1 and m.active = true
`

func (q *Queries) MfaEnabled(ctx context.Context, userID int32) (bool, error) {
	row := q.db.QueryRow(ctx, mfaEnabled, userID)
	var enabled bool
	err := row.Scan(&enabled)
	return enabled, err
}

const renameMfaAccount = `-- name: RenameMfaAccount :one
update mfa_accounts
set meta = jsonb_set(meta, '{name}', to_jsonb($1::text), true)
where id = $2 and user_id = $3 returning id, user_id, account_type, meta, active, created_at, updated_at, last_used_at, preferred
`

type RenameMfaAccountParams struct {
	NewName   string      `json:"new_name"`
	AccountID pgtype.UUID `json:"account_id"`
	UserID    int32       `json:"user_id"`
}

func (q *Queries) RenameMfaAccount(ctx context.Context, arg RenameMfaAccountParams) (MfaAccount, error) {
	row := q.db.QueryRow(ctx, renameMfaAccount, arg.NewName, arg.AccountID, arg.UserID)
	var i MfaAccount
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountType,
		&i.Meta,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
		&i.Preferred,
	)
	return i, err
}

const saveBackupCodes = `-- name: SaveBackupCodes :exec
insert into mfa_backup_tokens(user_id, hashed_token) values ($1, $2)
`

type SaveBackupCodesParams struct {
	UserID      int32  `json:"user_id"`
	HashedToken string `json:"hashed_token"`
}

func (q *Queries) SaveBackupCodes(ctx context.Context, arg SaveBackupCodesParams) error {
	_, err := q.db.Exec(ctx, saveBackupCodes, arg.UserID, arg.HashedToken)
	return err
}

const setMfaAccountLastUsed = `-- name: SetMfaAccountLastUsed :exec
update mfa_accounts
set last_used_at = now()
where id = $1
`

func (q *Queries) SetMfaAccountLastUsed(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, setMfaAccountLastUsed, id)
	return err
}

const setPreferredMfaAccount = `-- name: SetPreferredMfaAccount :exec
update mfa_accounts
set preferred = case
    when id = $1 then true
    else false
end
where user_id = $2
`

type SetPreferredMfaAccountParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID int32       `json:"user_id"`
}

func (q *Queries) SetPreferredMfaAccount(ctx context.Context, arg SetPreferredMfaAccountParams) error {
	_, err := q.db.Exec(ctx, setPreferredMfaAccount, arg.ID, arg.UserID)
	return err
}
