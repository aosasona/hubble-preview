// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0

package queries

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
	"go.trulyao.dev/hubble/web/pkg/document"
	"go.trulyao.dev/hubble/web/pkg/rbac"
)

type EntryChunkEmbeddingStatus string

const (
	EntryChunkEmbeddingStatusPending    EntryChunkEmbeddingStatus = "pending"
	EntryChunkEmbeddingStatusProcessing EntryChunkEmbeddingStatus = "processing"
	EntryChunkEmbeddingStatusDone       EntryChunkEmbeddingStatus = "done"
	EntryChunkEmbeddingStatusFailed     EntryChunkEmbeddingStatus = "failed"
)

func (e *EntryChunkEmbeddingStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EntryChunkEmbeddingStatus(s)
	case string:
		*e = EntryChunkEmbeddingStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for EntryChunkEmbeddingStatus: %T", src)
	}
	return nil
}

type NullEntryChunkEmbeddingStatus struct {
	EntryChunkEmbeddingStatus EntryChunkEmbeddingStatus `json:"entry_chunk_embedding_status"`
	Valid                     bool                      `json:"valid"` // Valid is true if EntryChunkEmbeddingStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEntryChunkEmbeddingStatus) Scan(value interface{}) error {
	if value == nil {
		ns.EntryChunkEmbeddingStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EntryChunkEmbeddingStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEntryChunkEmbeddingStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EntryChunkEmbeddingStatus), nil
}

func (e EntryChunkEmbeddingStatus) Valid() bool {
	switch e {
	case EntryChunkEmbeddingStatusPending,
		EntryChunkEmbeddingStatusProcessing,
		EntryChunkEmbeddingStatusDone,
		EntryChunkEmbeddingStatusFailed:
		return true
	}
	return false
}

func AllEntryChunkEmbeddingStatusValues() []EntryChunkEmbeddingStatus {
	return []EntryChunkEmbeddingStatus{
		EntryChunkEmbeddingStatusPending,
		EntryChunkEmbeddingStatusProcessing,
		EntryChunkEmbeddingStatusDone,
		EntryChunkEmbeddingStatusFailed,
	}
}

type EntryStatus string

const (
	EntryStatusQueued     EntryStatus = "queued"
	EntryStatusProcessing EntryStatus = "processing"
	EntryStatusCompleted  EntryStatus = "completed"
	EntryStatusFailed     EntryStatus = "failed"
	EntryStatusCanceled   EntryStatus = "canceled"
	EntryStatusPaused     EntryStatus = "paused"
)

func (e *EntryStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EntryStatus(s)
	case string:
		*e = EntryStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for EntryStatus: %T", src)
	}
	return nil
}

type NullEntryStatus struct {
	EntryStatus EntryStatus `json:"entry_status"`
	Valid       bool        `json:"valid"` // Valid is true if EntryStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEntryStatus) Scan(value interface{}) error {
	if value == nil {
		ns.EntryStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EntryStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEntryStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EntryStatus), nil
}

func (e EntryStatus) Valid() bool {
	switch e {
	case EntryStatusQueued,
		EntryStatusProcessing,
		EntryStatusCompleted,
		EntryStatusFailed,
		EntryStatusCanceled,
		EntryStatusPaused:
		return true
	}
	return false
}

func AllEntryStatusValues() []EntryStatus {
	return []EntryStatus{
		EntryStatusQueued,
		EntryStatusProcessing,
		EntryStatusCompleted,
		EntryStatusFailed,
		EntryStatusCanceled,
		EntryStatusPaused,
	}
}

type MfaAccountType string

const (
	MfaAccountTypeTotp  MfaAccountType = "totp"
	MfaAccountTypeEmail MfaAccountType = "email"
)

func (e *MfaAccountType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MfaAccountType(s)
	case string:
		*e = MfaAccountType(s)
	default:
		return fmt.Errorf("unsupported scan type for MfaAccountType: %T", src)
	}
	return nil
}

type NullMfaAccountType struct {
	MfaAccountType MfaAccountType `json:"mfa_account_type"`
	Valid          bool           `json:"valid"` // Valid is true if MfaAccountType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMfaAccountType) Scan(value interface{}) error {
	if value == nil {
		ns.MfaAccountType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MfaAccountType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMfaAccountType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MfaAccountType), nil
}

func (e MfaAccountType) Valid() bool {
	switch e {
	case MfaAccountTypeTotp,
		MfaAccountTypeEmail:
		return true
	}
	return false
}

func AllMfaAccountTypeValues() []MfaAccountType {
	return []MfaAccountType{
		MfaAccountTypeTotp,
		MfaAccountTypeEmail,
	}
}

type PluginMode string

const (
	PluginModeOnCreate   PluginMode = "on_create"
	PluginModeBackground PluginMode = "background"
)

func (e *PluginMode) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PluginMode(s)
	case string:
		*e = PluginMode(s)
	default:
		return fmt.Errorf("unsupported scan type for PluginMode: %T", src)
	}
	return nil
}

type NullPluginMode struct {
	PluginMode PluginMode `json:"plugin_mode"`
	Valid      bool       `json:"valid"` // Valid is true if PluginMode is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPluginMode) Scan(value interface{}) error {
	if value == nil {
		ns.PluginMode, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PluginMode.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPluginMode) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PluginMode), nil
}

func (e PluginMode) Valid() bool {
	switch e {
	case PluginModeOnCreate,
		PluginModeBackground:
		return true
	}
	return false
}

func AllPluginModeValues() []PluginMode {
	return []PluginMode{
		PluginModeOnCreate,
		PluginModeBackground,
	}
}

type PluginScope string

const (
	PluginScopeWorkspace PluginScope = "workspace"
	PluginScopeGlobal    PluginScope = "global"
)

func (e *PluginScope) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PluginScope(s)
	case string:
		*e = PluginScope(s)
	default:
		return fmt.Errorf("unsupported scan type for PluginScope: %T", src)
	}
	return nil
}

type NullPluginScope struct {
	PluginScope PluginScope `json:"plugin_scope"`
	Valid       bool        `json:"valid"` // Valid is true if PluginScope is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPluginScope) Scan(value interface{}) error {
	if value == nil {
		ns.PluginScope, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PluginScope.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPluginScope) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PluginScope), nil
}

func (e PluginScope) Valid() bool {
	switch e {
	case PluginScopeWorkspace,
		PluginScopeGlobal:
		return true
	}
	return false
}

func AllPluginScopeValues() []PluginScope {
	return []PluginScope{
		PluginScopeWorkspace,
		PluginScopeGlobal,
	}
}

type PluginSourceAuthMethod string

const (
	PluginSourceAuthMethodNone  PluginSourceAuthMethod = "none"
	PluginSourceAuthMethodSsh   PluginSourceAuthMethod = "ssh"
	PluginSourceAuthMethodHttps PluginSourceAuthMethod = "https"
)

func (e *PluginSourceAuthMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PluginSourceAuthMethod(s)
	case string:
		*e = PluginSourceAuthMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for PluginSourceAuthMethod: %T", src)
	}
	return nil
}

type NullPluginSourceAuthMethod struct {
	PluginSourceAuthMethod PluginSourceAuthMethod `json:"plugin_source_auth_method"`
	Valid                  bool                   `json:"valid"` // Valid is true if PluginSourceAuthMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPluginSourceAuthMethod) Scan(value interface{}) error {
	if value == nil {
		ns.PluginSourceAuthMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PluginSourceAuthMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPluginSourceAuthMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PluginSourceAuthMethod), nil
}

func (e PluginSourceAuthMethod) Valid() bool {
	switch e {
	case PluginSourceAuthMethodNone,
		PluginSourceAuthMethodSsh,
		PluginSourceAuthMethodHttps:
		return true
	}
	return false
}

func AllPluginSourceAuthMethodValues() []PluginSourceAuthMethod {
	return []PluginSourceAuthMethod{
		PluginSourceAuthMethodNone,
		PluginSourceAuthMethodSsh,
		PluginSourceAuthMethodHttps,
	}
}

type PluginSourceType string

const (
	PluginSourceTypeGit   PluginSourceType = "git"
	PluginSourceTypeLocal PluginSourceType = "local"
)

func (e *PluginSourceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PluginSourceType(s)
	case string:
		*e = PluginSourceType(s)
	default:
		return fmt.Errorf("unsupported scan type for PluginSourceType: %T", src)
	}
	return nil
}

type NullPluginSourceType struct {
	PluginSourceType PluginSourceType `json:"plugin_source_type"`
	Valid            bool             `json:"valid"` // Valid is true if PluginSourceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPluginSourceType) Scan(value interface{}) error {
	if value == nil {
		ns.PluginSourceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PluginSourceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPluginSourceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PluginSourceType), nil
}

func (e PluginSourceType) Valid() bool {
	switch e {
	case PluginSourceTypeGit,
		PluginSourceTypeLocal:
		return true
	}
	return false
}

func AllPluginSourceTypeValues() []PluginSourceType {
	return []PluginSourceType{
		PluginSourceTypeGit,
		PluginSourceTypeLocal,
	}
}

type PluginSyncStatus string

const (
	PluginSyncStatusIdle    PluginSyncStatus = "idle"
	PluginSyncStatusSyncing PluginSyncStatus = "syncing"
	PluginSyncStatusError   PluginSyncStatus = "error"
)

func (e *PluginSyncStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PluginSyncStatus(s)
	case string:
		*e = PluginSyncStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for PluginSyncStatus: %T", src)
	}
	return nil
}

type NullPluginSyncStatus struct {
	PluginSyncStatus PluginSyncStatus `json:"plugin_sync_status"`
	Valid            bool             `json:"valid"` // Valid is true if PluginSyncStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPluginSyncStatus) Scan(value interface{}) error {
	if value == nil {
		ns.PluginSyncStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PluginSyncStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPluginSyncStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PluginSyncStatus), nil
}

func (e PluginSyncStatus) Valid() bool {
	switch e {
	case PluginSyncStatusIdle,
		PluginSyncStatusSyncing,
		PluginSyncStatusError:
		return true
	}
	return false
}

func AllPluginSyncStatusValues() []PluginSyncStatus {
	return []PluginSyncStatus{
		PluginSyncStatusIdle,
		PluginSyncStatusSyncing,
		PluginSyncStatusError,
	}
}

type VersioningStrategy string

const (
	VersioningStrategyTag    VersioningStrategy = "tag"
	VersioningStrategyCommit VersioningStrategy = "commit"
)

func (e *VersioningStrategy) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = VersioningStrategy(s)
	case string:
		*e = VersioningStrategy(s)
	default:
		return fmt.Errorf("unsupported scan type for VersioningStrategy: %T", src)
	}
	return nil
}

type NullVersioningStrategy struct {
	VersioningStrategy VersioningStrategy `json:"versioning_strategy"`
	Valid              bool               `json:"valid"` // Valid is true if VersioningStrategy is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullVersioningStrategy) Scan(value interface{}) error {
	if value == nil {
		ns.VersioningStrategy, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.VersioningStrategy.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullVersioningStrategy) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.VersioningStrategy), nil
}

func (e VersioningStrategy) Valid() bool {
	switch e {
	case VersioningStrategyTag,
		VersioningStrategyCommit:
		return true
	}
	return false
}

func AllVersioningStrategyValues() []VersioningStrategy {
	return []VersioningStrategy{
		VersioningStrategyTag,
		VersioningStrategyCommit,
	}
}

type AuthSession struct {
	ID        int32              `json:"id"`
	UserID    int32              `json:"user_id"`
	Token     string             `json:"token"`
	Meta      []byte             `json:"meta"`
	IssuedAt  pgtype.Timestamptz `json:"issued_at"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

type Collection struct {
	ID          int32              `json:"id"`
	PublicID    pgtype.UUID        `json:"public_id"`
	Name        string             `json:"name"`
	WorkspaceID int32              `json:"workspace_id"`
	Description pgtype.Text        `json:"description"`
	AvatarID    pgtype.Text        `json:"avatar_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
	Slug        pgtype.Text        `json:"slug"`
	OwnerID     int32              `json:"owner_id"`
}

type CollectionMember struct {
	ID               int32              `json:"id"`
	CollectionID     int32              `json:"collection_id"`
	UserID           int32              `json:"user_id"`
	ExtraPermissions []byte             `json:"extra_permissions"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
	BitmaskRole      rbac.Role          `json:"bitmask_role"`
}

type EntriesQueue struct {
	ID          pgtype.UUID           `json:"id"`
	EntryID     int32                 `json:"entry_id"`
	Payload     document.QueuePayload `json:"payload"`
	Status      EntryStatus           `json:"status"`
	Attempts    int32                 `json:"attempts"`
	MaxAttempts int32                 `json:"max_attempts"`
	AvailableAt pgtype.Timestamp      `json:"available_at"`
	CreatedAt   pgtype.Timestamp      `json:"created_at"`
	UpdatedAt   pgtype.Timestamp      `json:"updated_at"`
}

type Entry struct {
	ID            int32              `json:"id"`
	Origin        pgtype.UUID        `json:"origin"`
	Name          string             `json:"name"`
	Content       pgtype.Text        `json:"content"`
	FileID        pgtype.Text        `json:"file_id"`
	Version       int32              `json:"version"`
	EntryType     document.EntryType `json:"entry_type"`
	Checksum      pgtype.Text        `json:"checksum"`
	ParentID      pgtype.Int4        `json:"parent_id"`
	CollectionID  int32              `json:"collection_id"`
	AddedBy       int32              `json:"added_by"`
	LastUpdatedBy int32              `json:"last_updated_by"`
	Meta          []byte             `json:"meta"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	DeletedAt     pgtype.Timestamptz `json:"deleted_at"`
	ArchivedAt    pgtype.Timestamptz `json:"archived_at"`
	// Size of the file in bytes
	FilesizeBytes int64       `json:"filesize_bytes"`
	PublicID      pgtype.UUID `json:"public_id"`
	// The plain text version of the entry. This is used for chunks and indexing.
	TextContent pgtype.Text `json:"text_content"`
}

type EntryChunk struct {
	ID         int32              `json:"id"`
	EntryID    pgtype.Int4        `json:"entry_id"`
	ChunkIndex int32              `json:"chunk_index"`
	MinVersion int32              `json:"min_version"`
	Content    pgtype.Text        `json:"content"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
	DeletedAt  pgtype.Timestamptz `json:"deleted_at"`
	// The full-text vector of the chunk
	TextVector interface{} `json:"text_vector"`
	// The semantic vector of the chunk using an embedding model
	SemanticVector           pgvector.Vector           `json:"semantic_vector"`
	Language                 pgtype.Text               `json:"language"`
	EmbeddingStatus          EntryChunkEmbeddingStatus `json:"embedding_status"`
	EmbeddingStatusUpdatedAt pgtype.Timestamptz        `json:"embedding_status_updated_at"`
	LastEmbeddingError       pgtype.Text               `json:"last_embedding_error"`
	LastEmbeddingErrorAt     pgtype.Timestamptz        `json:"last_embedding_error_at"`
	EmbeddingErrorCount      pgtype.Int4               `json:"embedding_error_count"`
}

type InstalledPlugin struct {
	ID pgtype.UUID `json:"id"`
	// A unique identifier for the plugin, this is generated in the system as a hash from the source data and the workspace itself. It is also used to identify local files related to the plugin.
	PluginIdentifier string               `json:"plugin_identifier"`
	WorkspaceID      pgtype.Int4          `json:"workspace_id"`
	SourceID         pgtype.UUID          `json:"source_id"`
	Name             string               `json:"name"`
	Description      pgtype.Text          `json:"description"`
	Scope            PluginScope          `json:"scope"`
	Modes            []PluginMode         `json:"modes"`
	EntryTypes       []document.EntryType `json:"entry_types"`
	// The SHA-256 of the WASM file provided as part of the build
	VersionSha    string             `json:"version_sha"`
	LastUpdatedAt pgtype.Timestamptz `json:"last_updated_at"`
	AddedAt       pgtype.Timestamptz `json:"added_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	Metadata      []byte             `json:"metadata"`
	Tags          []string           `json:"tags"`
	Privileges    []PluginPrivilege  `json:"privileges"`
}

type MfaAccount struct {
	ID          pgtype.UUID        `json:"id"`
	UserID      int32              `json:"user_id"`
	AccountType MfaAccountType     `json:"account_type"`
	Meta        []byte             `json:"meta"`
	Active      bool               `json:"active"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	LastUsedAt  pgtype.Timestamptz `json:"last_used_at"`
	Preferred   bool               `json:"preferred"`
}

type MfaBackupToken struct {
	ID          int32              `json:"id"`
	UserID      int32              `json:"user_id"`
	HashedToken string             `json:"hashed_token"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UsedAt      pgtype.Timestamptz `json:"used_at"`
}

type PluginSource struct {
	ID pgtype.UUID `json:"id"`
	// The workspace that this plugin source was added to. This is used to determine the scope of the plugin source.
	WorkspaceID        pgtype.Int4            `json:"workspace_id"`
	Name               string                 `json:"name"`
	Description        pgtype.Text            `json:"description"`
	Author             string                 `json:"author"`
	DisabledAt         pgtype.Timestamptz     `json:"disabled_at"`
	VersioningStrategy VersioningStrategy     `json:"versioning_strategy"`
	GitRemote          pgtype.Text            `json:"git_remote"`
	AuthMethod         PluginSourceAuthMethod `json:"auth_method"`
	VersionID          pgtype.Text            `json:"version_id"`
	SyncStatus         PluginSyncStatus       `json:"sync_status"`
	LastSyncError      pgtype.Text            `json:"last_sync_error"`
	LastSyncedAt       pgtype.Timestamptz     `json:"last_synced_at"`
	AddedAt            pgtype.Timestamptz     `json:"added_at"`
	UpdatedAt          pgtype.Timestamptz     `json:"updated_at"`
	// This contains things like the (encrypted) SSH key or HTTP credentials.
	Metadata []byte `json:"metadata"`
}

type PluginsKv struct {
	ID        pgtype.UUID        `json:"id"`
	PluginID  string             `json:"plugin_id"`
	Key       string             `json:"key"`
	Value     string             `json:"value"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

type Tag struct {
	ID           int32              `json:"id"`
	Name         string             `json:"name"`
	Description  pgtype.Text        `json:"description"`
	Color        pgtype.Text        `json:"color"`
	CollectionID int32              `json:"collection_id"`
	CreatedBy    int32              `json:"created_by"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

type TotpSecret struct {
	ID        int32              `json:"id"`
	AccountID pgtype.UUID        `json:"account_id"`
	Hash      []byte             `json:"hash"`
	Version   int16              `json:"version"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

type User struct {
	ID             int32              `json:"id"`
	PublicID       pgtype.UUID        `json:"public_id"`
	FirstName      string             `json:"first_name"`
	LastName       string             `json:"last_name"`
	Email          string             `json:"email"`
	Username       string             `json:"username"`
	HashedPassword string             `json:"hashed_password"`
	EmailVerified  bool               `json:"email_verified"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
	AvatarID       pgtype.Text        `json:"avatar_id"`
}

type Workspace struct {
	ID                   int32              `json:"id"`
	PublicID             pgtype.UUID        `json:"public_id"`
	DisplayName          string             `json:"display_name"`
	OwnerID              int32              `json:"owner_id"`
	Description          pgtype.Text        `json:"description"`
	AvatarID             pgtype.Text        `json:"avatar_id"`
	EnablePublicIndexing bool               `json:"enable_public_indexing"`
	InviteOnly           bool               `json:"invite_only"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	DeletedAt            pgtype.Timestamptz `json:"deleted_at"`
	Slug                 pgtype.Text        `json:"slug"`
}

type WorkspaceInvite struct {
	ID          int32              `json:"id"`
	InviteID    pgtype.UUID        `json:"invite_id"`
	WorkspaceID int32              `json:"workspace_id"`
	InvitedBy   int32              `json:"invited_by"`
	InvitedAt   pgtype.Timestamptz `json:"invited_at"`
	AcceptedAt  pgtype.Timestamptz `json:"accepted_at"`
	DeclinedAt  pgtype.Timestamptz `json:"declined_at"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
	Email       string             `json:"email"`
	Role        rbac.Role          `json:"role"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

type WorkspaceMember struct {
	ID               int32              `json:"id"`
	WorkspaceID      int32              `json:"workspace_id"`
	UserID           int32              `json:"user_id"`
	BitmaskRole      rbac.Role          `json:"bitmask_role"`
	ExtraPermissions []byte             `json:"extra_permissions"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
}
